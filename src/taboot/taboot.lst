CCS PCH C Compiler, Version 4.030, 38055               08-Jan-12 18:41

               Filename: C:\Dev1\Linux\tab1\taboot\src\taboot.lst

               ROM used: 8538 bytes (26%)
                         Largest free fragment is 24230
               RAM used: 15 (1%) at main() level
                         304 (20%) worst case
               Stack:    7 locations

*
0000:  GOTO   2014
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... //  taboot Firmware 
.................... //  This code will initialize an FPGA from SPI Flash Ram 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // Compilation Swithces 
.................... //------------------------------------------------------------------------------ 
.................... #define DEBUG     1     // Suppress debug messages by setting to 0 
.................... #define FLASHRAM  1     // Set to 1 to include Flash RAM routines 
.................... //------------------------------------------------------------------------------ 
.................... #include "taboot.h" 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // taboot Driver code                                          
.................... // DonnaWare International LLP Copyright (2001) All Rights Reserved         
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #include <18F2520.h>               // Proceesor definitions 
.................... //////// Standard Header file for the PIC18F2520 device //////////////// 
.................... #device PIC18F2520 
.................... #list 
....................  
.................... #device  *=16 adc=8                // Use 16 bit pointers, Use 8 bit ADC values 
.................... #use     delay(clock=20000000)     // Set device crystal speed 
*
04B6:  CLRF   FEA
04B8:  MOVLW  35
04BA:  MOVWF  FE9
04BC:  MOVF   FEF,W
04BE:  BZ    04DA
04C0:  MOVLW  06
04C2:  MOVWF  01
04C4:  CLRF   00
04C6:  DECFSZ 00,F
04C8:  BRA    04C6
04CA:  DECFSZ 01,F
04CC:  BRA    04C4
04CE:  MOVLW  7B
04D0:  MOVWF  00
04D2:  DECFSZ 00,F
04D4:  BRA    04D2
04D6:  DECFSZ FEF,F
04D8:  BRA    04C0
04DA:  RETLW  00
.................... //------------------------------------------------------------------------------ 
.................... // Set up microcontroller fuses 
.................... // (These are ignored when used with bootloader) 
.................... //------------------------------------------------------------------------------ 
.................... #fuses  NOWDT, HS, NOPUT, NOPROTECT, NOBROWNOUT, NOCPD, NOWRT, NODEBUG 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  Set up RS232 interface 
.................... //------------------------------------------------------------------------------ 
.................... #use rs232(baud=230400,bits=8,parity=N,xmit=PIN_C6,rcv=PIN_C7) 
.................... //#use rs232(baud=115200,bits=8,parity=N,xmit=PIN_C6,rcv=PIN_C7) 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  Use fast I/O for all Ports 
.................... //------------------------------------------------------------------------------ 
.................... #use fast_io(A)      // Use Fast I/O for Port A 
.................... #use fast_io(B)      // Use Fast I/O for Port B 
.................... #use fast_io(C)      // Use Fast I/O for Port C 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //    I/O Definitions 
.................... //------------------------------------------------------------------------------ 
.................... #define Spare_A0     PIN_A0          // Spare Pin 
.................... #define FPGAClock    PIN_A1          // FPGA Serial upload clock line 
.................... #define FPGADOut     PIN_A2          // FPGA Serial upload data line 
.................... #define FPGALoad     PIN_A3          // FPGA Serial upload select line 
.................... #define Spare_A4     PIN_A4          // Spare Pin 
.................... #define PS5V_EN      PIN_A5          // 5V PS enable 
....................  
.................... #define Button       PIN_B0          // On Off Button Pin 
.................... #define TestLED      PIN_B1          // Test LED (Active high) 
.................... #define Spare_B2     PIN_B2          // Spare Pin 
.................... #define SysReset     PIN_B3          // Resets FPGA and Main CPU 
.................... #define Spare_B4     PIN_B4          // Spare Pin 
.................... #define Spare_B5     PIN_B5          // Spare Pin 
.................... #define Spare_B6     PIN_B6          // Spare Pin 
.................... #define Spare_B7     PIN_B7          // Spare Pin 
....................  
.................... #define SSEL         PIN_C0          // SPI Enable 
.................... #define Spare_C1     PIN_C1          // Spare Pin 
.................... #define BACKLITE     PIN_C2          // LCD Backlight PWM control 
.................... #define SCK          PIN_C3          // SPI Clock 
.................... #define MISO         PIN_C4          // SPI Input - Device to MCU 
.................... #define MOSI         PIN_C5          // SPI Output - MCU to Device 
.................... #define RS232_Tx     PIN_C6          // RS2323 pin 
.................... #define RS232_Rx     PIN_C7          // RS2323 pin 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //    Standard includes 
.................... //------------------------------------------------------------------------------ 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
*
0F84:  MOVLW  7F
0F86:  MOVWF  1A
0F88:  CLRF   1B
0F8A:  CLRF   1C
0F8C:  CLRF   1D
....................    float result = 0.0; 
0F8E:  CLRF   1E
0F90:  CLRF   1F
0F92:  CLRF   20
0F94:  CLRF   21
....................    int sign = 0; 
0F96:  CLRF   22
....................    char c; 
....................    int ptr = 0; 
0F98:  CLRF   24
....................  
....................    c = s[ptr++]; 
0F9A:  MOVF   24,W
0F9C:  INCF   24,F
0F9E:  CLRF   03
0FA0:  ADDWF  18,W
0FA2:  MOVWF  FE9
0FA4:  MOVF   19,W
0FA6:  ADDWFC 03,W
0FA8:  MOVWF  FEA
0FAA:  MOVFF  FEF,23
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
0FAE:  MOVF   23,W
0FB0:  SUBLW  2F
0FB2:  BC    0FBA
0FB4:  MOVF   23,W
0FB6:  SUBLW  39
0FB8:  BC    0FCE
0FBA:  MOVF   23,W
0FBC:  SUBLW  2B
0FBE:  BZ    0FCE
0FC0:  MOVF   23,W
0FC2:  SUBLW  2D
0FC4:  BZ    0FCE
0FC6:  MOVF   23,W
0FC8:  SUBLW  2E
0FCA:  BTFSS  FD8.2
0FCC:  BRA    118C
....................       if(c == '-') { 
0FCE:  MOVF   23,W
0FD0:  SUBLW  2D
0FD2:  BNZ   0FEC
....................          sign = 1; 
0FD4:  MOVLW  01
0FD6:  MOVWF  22
....................          c = s[ptr++]; 
0FD8:  MOVF   24,W
0FDA:  INCF   24,F
0FDC:  CLRF   03
0FDE:  ADDWF  18,W
0FE0:  MOVWF  FE9
0FE2:  MOVF   19,W
0FE4:  ADDWFC 03,W
0FE6:  MOVWF  FEA
0FE8:  MOVFF  FEF,23
....................       } 
....................       if(c == '+') 
0FEC:  MOVF   23,W
0FEE:  SUBLW  2B
0FF0:  BNZ   1006
....................          c = s[ptr++]; 
0FF2:  MOVF   24,W
0FF4:  INCF   24,F
0FF6:  CLRF   03
0FF8:  ADDWF  18,W
0FFA:  MOVWF  FE9
0FFC:  MOVF   19,W
0FFE:  ADDWFC 03,W
1000:  MOVWF  FEA
1002:  MOVFF  FEF,23
....................  
....................       while((c >= '0' && c <= '9')) { 
1006:  MOVF   23,W
1008:  SUBLW  2F
100A:  BC    10C2
100C:  MOVF   23,W
100E:  SUBLW  39
1010:  BNC   10C2
....................          result = 10*result + c - '0'; 
1012:  CLRF   28
1014:  CLRF   27
1016:  MOVLW  20
1018:  MOVWF  26
101A:  MOVLW  82
101C:  MOVWF  25
101E:  MOVFF  21,2C
1022:  MOVFF  20,2B
1026:  MOVFF  1F,2A
102A:  MOVFF  1E,29
102E:  RCALL  0A98
1030:  MOVFF  00,25
1034:  MOVFF  01,26
1038:  MOVFF  02,27
103C:  MOVFF  03,28
1040:  CLRF   2A
1042:  MOVFF  23,29
1046:  RCALL  0B8A
1048:  BCF    FD8.1
104A:  MOVFF  28,30
104E:  MOVFF  27,2F
1052:  MOVFF  26,2E
1056:  MOVFF  25,2D
105A:  MOVFF  03,34
105E:  MOVFF  02,33
1062:  MOVFF  01,32
1066:  MOVFF  00,31
106A:  RCALL  0BC0
106C:  MOVFF  00,29
1070:  MOVFF  01,2A
1074:  MOVFF  02,2B
1078:  MOVFF  03,2C
107C:  BSF    FD8.1
107E:  MOVFF  03,30
1082:  MOVFF  02,2F
1086:  MOVFF  01,2E
108A:  MOVFF  00,2D
108E:  CLRF   34
1090:  CLRF   33
1092:  MOVLW  40
1094:  MOVWF  32
1096:  MOVLW  84
1098:  MOVWF  31
109A:  RCALL  0BC0
109C:  MOVFF  03,21
10A0:  MOVFF  02,20
10A4:  MOVFF  01,1F
10A8:  MOVFF  00,1E
....................          c = s[ptr++]; 
10AC:  MOVF   24,W
10AE:  INCF   24,F
10B0:  CLRF   03
10B2:  ADDWF  18,W
10B4:  MOVWF  FE9
10B6:  MOVF   19,W
10B8:  ADDWFC 03,W
10BA:  MOVWF  FEA
10BC:  MOVFF  FEF,23
....................       } 
10C0:  BRA    1006
....................  
....................       if (c == '.') { 
10C2:  MOVF   23,W
10C4:  SUBLW  2E
10C6:  BNZ   118C
....................          c = s[ptr++]; 
10C8:  MOVF   24,W
10CA:  INCF   24,F
10CC:  CLRF   03
10CE:  ADDWF  18,W
10D0:  MOVWF  FE9
10D2:  MOVF   19,W
10D4:  ADDWFC 03,W
10D6:  MOVWF  FEA
10D8:  MOVFF  FEF,23
....................          while((c >= '0' && c <= '9')) { 
10DC:  MOVF   23,W
10DE:  SUBLW  2F
10E0:  BC    118C
10E2:  MOVF   23,W
10E4:  SUBLW  39
10E6:  BNC   118C
....................              pow10 = pow10*10; 
10E8:  MOVFF  1D,28
10EC:  MOVFF  1C,27
10F0:  MOVFF  1B,26
10F4:  MOVFF  1A,25
10F8:  CLRF   2C
10FA:  CLRF   2B
10FC:  MOVLW  20
10FE:  MOVWF  2A
1100:  MOVLW  82
1102:  MOVWF  29
1104:  RCALL  0A98
1106:  MOVFF  03,1D
110A:  MOVFF  02,1C
110E:  MOVFF  01,1B
1112:  MOVFF  00,1A
....................              result += (c - '0')/pow10; 
1116:  MOVLW  30
1118:  SUBWF  23,W
111A:  CLRF   2A
111C:  MOVWF  29
111E:  RCALL  0B8A
1120:  MOVFF  03,29
1124:  MOVFF  02,28
1128:  MOVFF  01,27
112C:  MOVFF  00,26
1130:  MOVFF  1D,2D
1134:  MOVFF  1C,2C
1138:  MOVFF  1B,2B
113C:  MOVFF  1A,2A
1140:  RCALL  0E2A
1142:  BCF    FD8.1
1144:  MOVFF  21,30
1148:  MOVFF  20,2F
114C:  MOVFF  1F,2E
1150:  MOVFF  1E,2D
1154:  MOVFF  03,34
1158:  MOVFF  02,33
115C:  MOVFF  01,32
1160:  MOVFF  00,31
1164:  RCALL  0BC0
1166:  MOVFF  03,21
116A:  MOVFF  02,20
116E:  MOVFF  01,1F
1172:  MOVFF  00,1E
....................              c = s[ptr++]; 
1176:  MOVF   24,W
1178:  INCF   24,F
117A:  CLRF   03
117C:  ADDWF  18,W
117E:  MOVWF  FE9
1180:  MOVF   19,W
1182:  ADDWFC 03,W
1184:  MOVWF  FEA
1186:  MOVFF  FEF,23
....................          } 
118A:  BRA    10DC
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
118C:  DECFSZ 22,W
118E:  BRA    11BE
....................       result = -1*result; 
1190:  CLRF   28
1192:  CLRF   27
1194:  MOVLW  80
1196:  MOVWF  26
1198:  MOVLW  7F
119A:  MOVWF  25
119C:  MOVFF  21,2C
11A0:  MOVFF  20,2B
11A4:  MOVFF  1F,2A
11A8:  MOVFF  1E,29
11AC:  RCALL  0A98
11AE:  MOVFF  03,21
11B2:  MOVFF  02,20
11B6:  MOVFF  01,1F
11BA:  MOVFF  00,1E
....................    return(result); 
11BE:  MOVFF  1E,00
11C2:  MOVFF  1F,01
11C6:  MOVFF  20,02
11CA:  MOVFF  21,03
.................... } 
11CE:  GOTO   126C (RETURN)
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
12E6:  CLRF   3D
....................    sign = 0; 
12E8:  CLRF   3B
....................    base = 10; 
12EA:  MOVLW  0A
12EC:  MOVWF  3C
....................    result = 0; 
12EE:  CLRF   3A
12F0:  CLRF   39
12F2:  CLRF   38
12F4:  CLRF   37
....................  
....................    if (!s) 
12F6:  MOVF   35,W
12F8:  IORWF  36,W
12FA:  BNZ   1306
....................       return 0; 
12FC:  CLRF   00
12FE:  CLRF   01
1300:  CLRF   02
1302:  CLRF   03
1304:  BRA    155E
....................    c = s[index++]; 
1306:  MOVF   3D,W
1308:  INCF   3D,F
130A:  CLRF   03
130C:  ADDWF  35,W
130E:  MOVWF  FE9
1310:  MOVF   36,W
1312:  ADDWFC 03,W
1314:  MOVWF  FEA
1316:  MOVFF  FEF,3E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
131A:  MOVF   3E,W
131C:  SUBLW  2D
131E:  BNZ   133A
....................    { 
....................       sign = 1;         // Set the sign to negative 
1320:  MOVLW  01
1322:  MOVWF  3B
....................       c = s[index++]; 
1324:  MOVF   3D,W
1326:  INCF   3D,F
1328:  CLRF   03
132A:  ADDWF  35,W
132C:  MOVWF  FE9
132E:  MOVF   36,W
1330:  ADDWFC 03,W
1332:  MOVWF  FEA
1334:  MOVFF  FEF,3E
....................    } 
....................    else if (c == '+') 
1338:  BRA    1354
133A:  MOVF   3E,W
133C:  SUBLW  2B
133E:  BNZ   1354
....................    { 
....................       c = s[index++]; 
1340:  MOVF   3D,W
1342:  INCF   3D,F
1344:  CLRF   03
1346:  ADDWF  35,W
1348:  MOVWF  FE9
134A:  MOVF   36,W
134C:  ADDWFC 03,W
134E:  MOVWF  FEA
1350:  MOVFF  FEF,3E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1354:  MOVF   3E,W
1356:  SUBLW  2F
1358:  BTFSC  FD8.0
135A:  BRA    152E
135C:  MOVF   3E,W
135E:  SUBLW  39
1360:  BTFSS  FD8.0
1362:  BRA    152E
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1364:  MOVF   3E,W
1366:  SUBLW  30
1368:  BNZ   13AC
136A:  CLRF   03
136C:  MOVF   3D,W
136E:  ADDWF  35,W
1370:  MOVWF  FE9
1372:  MOVF   36,W
1374:  ADDWFC 03,W
1376:  MOVWF  FEA
1378:  MOVF   FEF,W
137A:  SUBLW  78
137C:  BZ    1392
137E:  CLRF   03
1380:  MOVF   3D,W
1382:  ADDWF  35,W
1384:  MOVWF  FE9
1386:  MOVF   36,W
1388:  ADDWFC 03,W
138A:  MOVWF  FEA
138C:  MOVF   FEF,W
138E:  SUBLW  58
1390:  BNZ   13AC
....................       { 
....................          base = 16; 
1392:  MOVLW  10
1394:  MOVWF  3C
....................          index++; 
1396:  INCF   3D,F
....................          c = s[index++]; 
1398:  MOVF   3D,W
139A:  INCF   3D,F
139C:  CLRF   03
139E:  ADDWF  35,W
13A0:  MOVWF  FE9
13A2:  MOVF   36,W
13A4:  ADDWFC 03,W
13A6:  MOVWF  FEA
13A8:  MOVFF  FEF,3E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
13AC:  MOVF   3C,W
13AE:  SUBLW  0A
13B0:  BNZ   1432
....................       { 
....................          while (c >= '0' && c <= '9') { 
13B2:  MOVF   3E,W
13B4:  SUBLW  2F
13B6:  BC    1430
13B8:  MOVF   3E,W
13BA:  SUBLW  39
13BC:  BNC   1430
....................             result = (result << 1) + (result << 3);  // result *= 10; 
13BE:  BCF    FD8.0
13C0:  RLCF   37,W
13C2:  MOVWF  40
13C4:  RLCF   38,W
13C6:  MOVWF  41
13C8:  RLCF   39,W
13CA:  MOVWF  42
13CC:  RLCF   3A,W
13CE:  MOVWF  43
13D0:  RLCF   37,W
13D2:  MOVWF  00
13D4:  RLCF   38,W
13D6:  MOVWF  01
13D8:  RLCF   39,W
13DA:  MOVWF  02
13DC:  RLCF   3A,W
13DE:  MOVWF  03
13E0:  RLCF   00,F
13E2:  RLCF   01,F
13E4:  RLCF   02,F
13E6:  RLCF   03,F
13E8:  RLCF   00,F
13EA:  RLCF   01,F
13EC:  RLCF   02,F
13EE:  RLCF   03,F
13F0:  MOVLW  F8
13F2:  ANDWF  00,F
13F4:  MOVF   00,W
13F6:  ADDWF  40,W
13F8:  MOVWF  37
13FA:  MOVF   01,W
13FC:  ADDWFC 41,W
13FE:  MOVWF  38
1400:  MOVF   02,W
1402:  ADDWFC 42,W
1404:  MOVWF  39
1406:  MOVF   03,W
1408:  ADDWFC 43,W
140A:  MOVWF  3A
....................             result += (c - '0'); 
140C:  MOVLW  30
140E:  SUBWF  3E,W
1410:  ADDWF  37,F
1412:  MOVLW  00
1414:  ADDWFC 38,F
1416:  ADDWFC 39,F
1418:  ADDWFC 3A,F
....................             c = s[index++]; 
141A:  MOVF   3D,W
141C:  INCF   3D,F
141E:  CLRF   03
1420:  ADDWF  35,W
1422:  MOVWF  FE9
1424:  MOVF   36,W
1426:  ADDWFC 03,W
1428:  MOVWF  FEA
142A:  MOVFF  FEF,3E
....................          } 
142E:  BRA    13B2
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
1430:  BRA    152E
1432:  MOVF   3C,W
1434:  SUBLW  10
1436:  BTFSS  FD8.2
1438:  BRA    152E
....................       { 
....................          c = toupper(c); 
143A:  MOVF   3E,W
143C:  SUBLW  60
143E:  BC    144C
1440:  MOVF   3E,W
1442:  SUBLW  7A
1444:  BNC   144C
1446:  MOVF   3E,W
1448:  ANDLW  DF
144A:  BRA    144E
144C:  MOVF   3E,W
144E:  MOVWF  3E
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
1450:  MOVF   3E,W
1452:  SUBLW  2F
1454:  BC    145C
1456:  MOVF   3E,W
1458:  SUBLW  39
145A:  BC    1468
145C:  MOVF   3E,W
145E:  SUBLW  40
1460:  BC    152E
1462:  MOVF   3E,W
1464:  SUBLW  46
1466:  BNC   152E
....................             if (c >= '0' && c <= '9') 
1468:  MOVF   3E,W
146A:  SUBLW  2F
146C:  BC    14BC
146E:  MOVF   3E,W
1470:  SUBLW  39
1472:  BNC   14BC
....................                result = (result << 4) + (c - '0'); 
1474:  RLCF   37,W
1476:  MOVWF  40
1478:  RLCF   38,W
147A:  MOVWF  41
147C:  RLCF   39,W
147E:  MOVWF  42
1480:  RLCF   3A,W
1482:  MOVWF  43
1484:  RLCF   40,F
1486:  RLCF   41,F
1488:  RLCF   42,F
148A:  RLCF   43,F
148C:  RLCF   40,F
148E:  RLCF   41,F
1490:  RLCF   42,F
1492:  RLCF   43,F
1494:  RLCF   40,F
1496:  RLCF   41,F
1498:  RLCF   42,F
149A:  RLCF   43,F
149C:  MOVLW  F0
149E:  ANDWF  40,F
14A0:  MOVLW  30
14A2:  SUBWF  3E,W
14A4:  ADDWF  40,W
14A6:  MOVWF  37
14A8:  MOVLW  00
14AA:  ADDWFC 41,W
14AC:  MOVWF  38
14AE:  MOVLW  00
14B0:  ADDWFC 42,W
14B2:  MOVWF  39
14B4:  MOVLW  00
14B6:  ADDWFC 43,W
14B8:  MOVWF  3A
....................             else 
14BA:  BRA    1504
....................                result = (result << 4) + (c - 'A' + 10); 
14BC:  RLCF   37,W
14BE:  MOVWF  40
14C0:  RLCF   38,W
14C2:  MOVWF  41
14C4:  RLCF   39,W
14C6:  MOVWF  42
14C8:  RLCF   3A,W
14CA:  MOVWF  43
14CC:  RLCF   40,F
14CE:  RLCF   41,F
14D0:  RLCF   42,F
14D2:  RLCF   43,F
14D4:  RLCF   40,F
14D6:  RLCF   41,F
14D8:  RLCF   42,F
14DA:  RLCF   43,F
14DC:  RLCF   40,F
14DE:  RLCF   41,F
14E0:  RLCF   42,F
14E2:  RLCF   43,F
14E4:  MOVLW  F0
14E6:  ANDWF  40,F
14E8:  MOVLW  41
14EA:  SUBWF  3E,W
14EC:  ADDLW  0A
14EE:  ADDWF  40,W
14F0:  MOVWF  37
14F2:  MOVLW  00
14F4:  ADDWFC 41,W
14F6:  MOVWF  38
14F8:  MOVLW  00
14FA:  ADDWFC 42,W
14FC:  MOVWF  39
14FE:  MOVLW  00
1500:  ADDWFC 43,W
1502:  MOVWF  3A
....................  
....................             c = s[index++];c = toupper(c); 
1504:  MOVF   3D,W
1506:  INCF   3D,F
1508:  CLRF   03
150A:  ADDWF  35,W
150C:  MOVWF  FE9
150E:  MOVF   36,W
1510:  ADDWFC 03,W
1512:  MOVWF  FEA
1514:  MOVF   FEF,W
1516:  MOVWF  3E
1518:  SUBLW  60
151A:  BC    1528
151C:  MOVF   3E,W
151E:  SUBLW  7A
1520:  BNC   1528
1522:  MOVF   3E,W
1524:  ANDLW  DF
1526:  BRA    152A
1528:  MOVF   3E,W
152A:  MOVWF  3E
....................          } 
152C:  BRA    1450
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
152E:  MOVF   3C,W
1530:  SUBLW  0A
1532:  BNZ   154E
1534:  DECFSZ 3B,W
1536:  BRA    154E
....................       result = -result; 
1538:  COMF   37,F
153A:  COMF   38,F
153C:  COMF   39,F
153E:  COMF   3A,F
1540:  INCF   37,F
1542:  BTFSC  FD8.2
1544:  INCF   38,F
1546:  BTFSC  FD8.2
1548:  INCF   39,F
154A:  BTFSC  FD8.2
154C:  INCF   3A,F
....................  
....................    return(result); 
154E:  MOVFF  37,00
1552:  MOVFF  38,01
1556:  MOVFF  39,02
155A:  MOVFF  3A,03
.................... } 
155E:  GOTO   16FE (RETURN)
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................          *((char *)endptr)=s+ptr; 
....................       } 
....................       else 
....................          *((char *)endptr)=s; 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-') 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................  
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //   Macros 
.................... //------------------------------------------------------------------------------ 
.................... #define HIGH_BYTE(var)  make8(var,1)     // Extracts high byte 
.................... #define LOW_BYTE(var)   make8(var,0)     // Extracts low byte 
.................... #define delay_ns(val)   delay_cycles(val)  // for 20Mhz xtal, 1 = 200ns (Same as a NOP) 
.................... #define set(var)        output_high(var) 
.................... #define clr(var)        output_low(var) 
.................... #define get(var)        input(var) 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //   Global Variables 
.................... //------------------------------------------------------------------------------ 
.................... int8  verbose;          // verbose mode 
.................... int8  but_state;        //  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  Get char with time out                 
.................... //------------------------------------------------------------------------------ 
.................... char getchto(int8 to) 
.................... { 
....................     int8 i; 
....................     char ch = 0xFF; 
....................     for(i = 0; i < to; i++) {   // Try a few times 
....................         if(kbhit()) { 
....................             ch = getch(); 
....................             break; 
....................         } 
....................         delay_ms(50);          // 50 ms delay 
....................     } 
....................     return(ch);                // Return the value 
.................... } 
....................    
.................... //-------------------------------------------------------------------------- 
.................... // Input hex data from std in and return int 
.................... //-------------------------------------------------------------------------- 
.................... int8 get1hex(void)  
.................... { 
....................    char digit; 
....................    digit = getc(); 
*
17C0:  BTFSS  F9E.5
17C2:  BRA    17C0
17C4:  MOVFF  FAE,11E
17C8:  MOVLB  1
....................    putc(digit); 
17CA:  MOVF   x1E,W
17CC:  BTFSS  F9E.4
17CE:  BRA    17CC
17D0:  MOVWF  FAD
....................    if(digit <= '9') return(digit - '0'); 
17D2:  MOVF   x1E,W
17D4:  SUBLW  39
17D6:  BNC   17E2
17D8:  MOVLW  30
17DA:  SUBWF  x1E,W
17DC:  MOVWF  01
17DE:  BRA    17FE
....................    else             return((toupper(digit) - 'A') + 10); 
17E0:  BRA    17FE
17E2:  MOVF   x1E,W
17E4:  SUBLW  60
17E6:  BC    17F4
17E8:  MOVF   x1E,W
17EA:  SUBLW  7A
17EC:  BNC   17F4
17EE:  MOVF   x1E,W
17F0:  ANDLW  DF
17F2:  BRA    17F6
17F4:  MOVF   x1E,W
17F6:  ADDLW  BF
17F8:  ADDLW  0A
17FA:  MOVWF  01
17FC:  BRA    17FE
.................... } 
17FE:  MOVLB  0
1800:  RETLW  00
.................... int8 gethex(void) // get 2 hex digits and return 8 bit int 
.................... { 
....................    return(get1hex()*16 + get1hex()); 
1802:  RCALL  17C0
1804:  MOVF   01,W
1806:  MULLW  10
1808:  MOVFF  FF3,11D
180C:  MOVLB  0
180E:  RCALL  17C0
1810:  MOVF   01,W
1812:  MOVLB  1
1814:  ADDWF  x1D,W
1816:  MOVWF  01
.................... } 
1818:  MOVLB  0
181A:  RETLW  00
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  EEPROM Programming: 
.................... //  Memory Map: 
.................... //  Addr        Description of values 
.................... //  ----        ---------------------------------------------------------------------- 
.................... //  0x00        pointer to eeprom addr of inital rbf, 0XFF=no fpga init 
.................... //  0x01        board reset, 0x01=reset on init, 0xFF=no init reset 
.................... //  0x02        verbosity level, 0x00=lowest, 0x01 next highest, etc 
.................... //  0x03        LCD Backlight PWM level 
.................... //  0x04        LCD Backlight Saved PWM level 
.................... //  0x05        reserved 
.................... //    . 
.................... //    . 
.................... //  0x0F        reserved 
.................... //  0x10 - 0x1F 1st flash file record 
.................... //  0x20 - 0x2F 2nd flash file record 
.................... //       . 
.................... //       . 
.................... //  0xF0 - 0xFF last flash file record 
.................... // 
.................... //  Flash File Record format: 
.................... //  0xX0        MSB of file flash addr 
.................... //  0xX1        ISB of file flash addr 
.................... //  0xX2        LSB of file flash addr 
.................... //  0xX3        MSB of file flash length 
.................... //  0xX4        ISB of file flash length 
.................... //  0xX5        LSB of file flash length 
.................... //  0xX6 - 0xXF File name or description field, free form ASCII 
.................... // 
.................... // Example: 
.................... // 0x10  00 00 00  01 A3 EA   "plaid.rbf"   // len=107498 
.................... // 0x20  02 00 00  01 B4 D1   "lcd1.rbf"    // len=111825 
.................... //------------------------------------------------------------------------------ 
.................... #define INIT_RBF    0x00 
.................... #define INIT_RESET  0x01 
.................... #define INIT_VERB   0x02 
.................... #define INIT_PWM    0x03 
.................... #define SAVED_PWM   0x04 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Read EEPROM data from specified input address 
.................... //------------------------------------------------------------------------------ 
.................... void ee_read(void)   
.................... {  
....................    int8 data; 
....................     
....................    if(verbose) { 
*
1862:  MOVF   0B,F
1864:  BZ    18D4
....................        printf("addr: 0x"); 
1866:  CLRF   10
1868:  MOVF   10,W
186A:  CALL   0004
186E:  INCF   10,F
1870:  MOVWF  00
1872:  MOVF   00,W
1874:  BTFSS  F9E.4
1876:  BRA    1874
1878:  MOVWF  FAD
187A:  MOVLW  08
187C:  SUBWF  10,W
187E:  BNZ   1868
....................        data = read_eeprom(gethex()); 
1880:  RCALL  1802
1882:  MOVFF  FF2,11
1886:  BCF    FF2.7
1888:  MOVFF  01,FA9
188C:  BCF    FA6.6
188E:  BCF    FA6.7
1890:  BSF    FA6.0
1892:  MOVF   FA8,W
1894:  BTFSC  11.7
1896:  BSF    FF2.7
1898:  MOVWF  0F
....................        printf(" data: 0x%02x\r\n", data); 
189A:  CLRF   10
189C:  MOVF   10,W
189E:  CALL   001E
18A2:  INCF   10,F
18A4:  MOVWF  00
18A6:  MOVF   00,W
18A8:  BTFSS  F9E.4
18AA:  BRA    18A8
18AC:  MOVWF  FAD
18AE:  MOVLW  09
18B0:  SUBWF  10,W
18B2:  BNZ   189C
18B4:  MOVFF  0F,112
18B8:  MOVLW  57
18BA:  MOVLB  1
18BC:  MOVWF  x13
18BE:  MOVLB  0
18C0:  RCALL  181C
18C2:  MOVLW  0D
18C4:  BTFSS  F9E.4
18C6:  BRA    18C4
18C8:  MOVWF  FAD
18CA:  MOVLW  0A
18CC:  BTFSS  F9E.4
18CE:  BRA    18CC
18D0:  MOVWF  FAD
....................    } 
....................    else { 
18D2:  BRA    191C
....................        data = read_eeprom(gethex()); 
18D4:  RCALL  1802
18D6:  MOVFF  FF2,11
18DA:  BCF    FF2.7
18DC:  MOVFF  01,FA9
18E0:  BCF    FA6.6
18E2:  BCF    FA6.7
18E4:  BSF    FA6.0
18E6:  MOVF   FA8,W
18E8:  BTFSC  11.7
18EA:  BSF    FF2.7
18EC:  MOVWF  0F
....................        printf("0x%02x\r\n", data); 
18EE:  MOVLW  30
18F0:  BTFSS  F9E.4
18F2:  BRA    18F0
18F4:  MOVWF  FAD
18F6:  MOVLW  78
18F8:  BTFSS  F9E.4
18FA:  BRA    18F8
18FC:  MOVWF  FAD
18FE:  MOVFF  0F,112
1902:  MOVLW  57
1904:  MOVLB  1
1906:  MOVWF  x13
1908:  MOVLB  0
190A:  RCALL  181C
190C:  MOVLW  0D
190E:  BTFSS  F9E.4
1910:  BRA    190E
1912:  MOVWF  FAD
1914:  MOVLW  0A
1916:  BTFSS  F9E.4
1918:  BRA    1916
191A:  MOVWF  FAD
....................    } 
.................... } 
191C:  GOTO   1F84 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Write EEPROM data to specified input address 
.................... //------------------------------------------------------------------------------ 
.................... void ee_write(void)  
.................... {  
....................    int8 addr; 
....................  
....................    if(verbose) { 
1920:  MOVF   0B,F
1922:  BZ    19B2
....................        printf("addr: 0x");  
1924:  CLRF   10
1926:  MOVF   10,W
1928:  CALL   0004
192C:  INCF   10,F
192E:  MOVWF  00
1930:  MOVF   00,W
1932:  BTFSS  F9E.4
1934:  BRA    1932
1936:  MOVWF  FAD
1938:  MOVLW  08
193A:  SUBWF  10,W
193C:  BNZ   1926
....................        addr = gethex(); 
193E:  RCALL  1802
1940:  MOVFF  01,0F
....................        printf(" data: 0x");  
1944:  CLRF   10
1946:  MOVF   10,W
1948:  CALL   003E
194C:  INCF   10,F
194E:  MOVWF  00
1950:  MOVF   00,W
1952:  BTFSS  F9E.4
1954:  BRA    1952
1956:  MOVWF  FAD
1958:  MOVLW  09
195A:  SUBWF  10,W
195C:  BNZ   1946
....................        write_eeprom(addr, gethex()); 
195E:  RCALL  1802
1960:  MOVFF  01,10
1964:  MOVFF  0F,FA9
1968:  MOVFF  01,FA8
196C:  BCF    FA6.6
196E:  BCF    FA6.7
1970:  BSF    FA6.2
1972:  MOVFF  FF2,00
1976:  BCF    FF2.7
1978:  MOVLB  F
197A:  MOVLW  55
197C:  MOVWF  FA7
197E:  MOVLW  AA
1980:  MOVWF  FA7
1982:  BSF    FA6.1
1984:  BTFSC  FA6.1
1986:  BRA    1984
1988:  BCF    FA6.2
198A:  MOVF   00,W
198C:  IORWF  FF2,F
....................        printf("\r\n eeprom data written");  
198E:  CLRF   10
1990:  MOVF   10,W
1992:  MOVLB  0
1994:  CALL   0058
1998:  INCF   10,F
199A:  MOVWF  00
199C:  MOVF   00,W
199E:  BTFSS  F9E.4
19A0:  BRA    199E
19A2:  MOVWF  FAD
19A4:  MOVLW  16
19A6:  SUBWF  10,W
19A8:  BTFSC  FD8.2
19AA:  BRA    19B0
19AC:  MOVLB  F
19AE:  BRA    1990
....................    } 
....................    else { 
19B0:  BRA    1A00
....................        addr = gethex(); 
19B2:  RCALL  1802
19B4:  MOVFF  01,0F
....................        printf(" ");  
19B8:  MOVLW  20
19BA:  BTFSS  F9E.4
19BC:  BRA    19BA
19BE:  MOVWF  FAD
....................        write_eeprom(addr, gethex()); 
19C0:  RCALL  1802
19C2:  MOVFF  01,10
19C6:  MOVFF  0F,FA9
19CA:  MOVFF  01,FA8
19CE:  BCF    FA6.6
19D0:  BCF    FA6.7
19D2:  BSF    FA6.2
19D4:  MOVFF  FF2,00
19D8:  BCF    FF2.7
19DA:  MOVLB  F
19DC:  MOVLW  55
19DE:  MOVWF  FA7
19E0:  MOVLW  AA
19E2:  MOVWF  FA7
19E4:  BSF    FA6.1
19E6:  BTFSC  FA6.1
19E8:  BRA    19E6
19EA:  BCF    FA6.2
19EC:  MOVF   00,W
19EE:  IORWF  FF2,F
....................        printf("\r\n");  
19F0:  MOVLW  0D
19F2:  BTFSS  F9E.4
19F4:  BRA    19F2
19F6:  MOVWF  FAD
19F8:  MOVLW  0A
19FA:  BTFSS  F9E.4
19FC:  BRA    19FA
19FE:  MOVWF  FAD
1A00:  MOVLB  0
....................    } 
.................... } 
1A02:  GOTO   1F88 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // Include Drivers 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #include "FPGA.h"             // FPGA driver 
.................... //============================================================================== 
.................... //============================================================================== 
.................... // FPGA Controler Routines 
.................... // 
.................... // FPGA.H -- FPGA Controller                                         
.................... // DonnaWare International LLP Copyright (2001) All Rights Reserved         
.................... //============================================================================== 
.................... //============================================================================== 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  Upload FPGA Firware  
.................... //  Un-comment these lines and set them according to your application. 
.................... // 
.................... // #define FPGAClock   PIN_xx      // FPGA Serial upload clock line 
.................... // #define FPGADOut    PIN_xx      // FPGA Serial upload data line 
.................... // #define FPGALoad    PIN_xx      // FPGA Serial upload select line 
.................... // #define FPGAReset   PIN_xx      // Reset 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  Upload FPGA Firware via RS232 Line 
.................... //------------------------------------------------------------------------------ 
.................... #define USEASM      1               // Use Assembly for speed 
.................... #define IOPORT      0xF80           // IO Port, A=F80, B=F81, C=F82, D=F83, E=F84 
.................... #define FPGAclk     1               // FPGA clock ( pin  75) 
.................... #define FPGAsio     2               // FPGA I/O data ( pin 76) 
.................... #define FPGAce      3               // FPGA Config line LO=reset HI=active 
.................... #define FPGA_SIO    IOPORT,FPGAsio  // FPGA SIO line LO=reset HI=active 
.................... #define FPGA_CLK    IOPORT,FPGAclk  // FPGA clock line 
.................... //-------------------------------------------------------------------------- 
.................... // LOAD FPGA Config Byte - Uploads a single byte of data to FPGA from RS232 port 
.................... // CAUTION: the USEASM option is needed to keep up with the RS232 input if 
.................... // the baud rate is high (eg. >115.2kbps), UNLESS, the #opt level is set to  
.................... // at least 9.  
.................... //-------------------------------------------------------------------------- 
.................... void LoadFPGAByte(byte Sdata) 
.................... { 
.................... #if USEASM 
....................     int8  Rbit, Rdata; 
....................     #asm 
....................             Movf    Sdata,W         // Store it for later 
*
05C2:  MOVF   36,W
....................             Movwf   Rdata           // Tempstore data 
05C4:  MOVWF  38
....................             Movlw   0x08            // Number of bits to send 
05C6:  MOVLW  08
....................             Movwf   Rbit            // Save it 
05C8:  MOVWF  37
....................     WBit:   Btfss   Rdata,0         // Check next bit 
05CA:  BTFSS  38.0
....................             Bcf     FPGA_SIO        // If clear send a zero 
05CC:  BCF    F80.2
....................             Btfsc   Rdata,0         // Check next bit 
05CE:  BTFSC  38.0
....................             Bsf     FPGA_SIO        // If set send a one 
05D0:  BSF    F80.2
....................             Bsf     FPGA_CLK        // Clock pin high 
05D2:  BSF    F80.1
....................             Rrcf    Rdata,F         // Rotate for next bit 
05D4:  RRCF   38,F
....................             Bcf     FPGA_CLK        // Raise clock pin 
05D6:  BCF    F80.1
....................             Decfsz  Rbit,F          // Decrement bit counter 
05D8:  DECFSZ 37,F
....................             Goto    WBit            // Do next bit 
05DA:  BRA    05CA
....................     #endasm 
.................... #else 
....................     int8 i; 
....................     
....................     for(i = 0; i < 8; ++i) { 
....................         output_bit(FPGADOut, shift_right(&SData,1,0));  // Send a data bit 
....................         output_low(FPGAClock); 
....................         output_high(FPGAClock);                         // Pulse the clock 
....................     } 
.................... #endif 
.................... } 
05DC:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Recieves a stream from RS232 line and uploads it to the FPGA 
.................... //------------------------------------------------------------------------------ 
.................... void Upload_RBF(void) 
.................... { 
....................     int32 i, rbflength;         // RBF file length in 256 byte blocks 
....................     char string[30]; 
....................      
....................     gets(string); 
*
16DC:  CLRF   FEA
16DE:  MOVLW  17
16E0:  MOVWF  FE9
16E2:  DECF   FE9,F
16E4:  INCF   FE9,F
16E6:  BTFSS  F9E.5
16E8:  BRA    16E6
16EA:  MOVFF  FAE,FEF
16EE:  MOVLW  0D
16F0:  SUBWF  FEF,W
16F2:  BNZ   16E4
16F4:  CLRF   FEF
....................     rbflength = atoi32(string); 
16F6:  CLRF   36
16F8:  MOVLW  17
16FA:  MOVWF  35
16FC:  BRA    12E6
16FE:  MOVFF  03,16
1702:  MOVFF  02,15
1706:  MOVFF  01,14
170A:  MOVFF  00,13
....................      
....................     Output_Low(FPGALoad);            // FPGA Upload pin 
170E:  BCF    F89.3
....................     delay_ms(10);                    // 50 ms delay to put FPGA into load mode 
1710:  MOVLW  0A
1712:  MOVWF  35
1714:  CALL   04B6
....................     Output_High(FPGALoad);           // FPGA Upload pin 
1718:  BSF    F89.3
....................     for(i = 0; i < rbflength; i++) { 
171A:  CLRF   12
171C:  CLRF   11
171E:  CLRF   10
1720:  CLRF   0F
1722:  MOVF   12,W
1724:  SUBWF  16,W
1726:  BNC   1762
1728:  BNZ   1740
172A:  MOVF   11,W
172C:  SUBWF  15,W
172E:  BNC   1762
1730:  BNZ   1740
1732:  MOVF   10,W
1734:  SUBWF  14,W
1736:  BNC   1762
1738:  BNZ   1740
173A:  MOVF   13,W
173C:  SUBWF  0F,W
173E:  BC    1762
....................         LoadFPGAByte(getch()); 
1740:  BTFSS  F9E.5
1742:  BRA    1740
1744:  MOVFF  FAE,35
1748:  MOVFF  FAE,36
174C:  CALL   05C2
....................     } 
1750:  MOVLW  01
1752:  ADDWF  0F,F
1754:  BTFSC  FD8.0
1756:  INCF   10,F
1758:  BTFSC  FD8.2
175A:  INCF   11,F
175C:  BTFSC  FD8.2
175E:  INCF   12,F
1760:  BRA    1722
....................      
....................     if(verbose) printf("\r\nrbf %Ld bytes received\r\n", rbflength); 
1762:  MOVF   0B,F
1764:  BZ    17B4
1766:  CLRF   35
1768:  MOVF   35,W
176A:  CALL   0080
176E:  INCF   35,F
1770:  MOVWF  00
1772:  MOVF   00,W
1774:  BTFSS  F9E.4
1776:  BRA    1774
1778:  MOVWF  FAD
177A:  MOVLW  06
177C:  SUBWF  35,W
177E:  BNZ   1768
1780:  MOVLW  41
1782:  MOVWF  FE9
1784:  MOVFF  16,39
1788:  MOVFF  15,38
178C:  MOVFF  14,37
1790:  MOVFF  13,36
1794:  BRA    15DC
1796:  MOVLW  09
1798:  MOVWF  36
179A:  MOVF   36,W
179C:  CALL   0080
17A0:  INCF   36,F
17A2:  MOVWF  00
17A4:  MOVF   00,W
17A6:  BTFSS  F9E.4
17A8:  BRA    17A6
17AA:  MOVWF  FAD
17AC:  MOVLW  1A
17AE:  SUBWF  36,W
17B0:  BNZ   179A
....................     else        putchar('F');                    // To signal Success 
17B2:  BRA    17BC
17B4:  MOVLW  46
17B6:  BTFSS  F9E.4
17B8:  BRA    17B6
17BA:  MOVWF  FAD
.................... } 
17BC:  GOTO   1F80 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //    End .h 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... #if FLASHRAM 
.................... #include "Flash.h" 
.................... //---------------------------------------------------------------------------- 
.................... //---------------------------------------------------------------------------- 
.................... //  S P I    F l a s h    F u n c t i o n s                                      
.................... //---------------------------------------------------------------------------- 
.................... //---------------------------------------------------------------------------- 
.................... #include "SST25V.h" 
.................... //------------------------------------------------------------------------------ 
.................... // Library for an SST25V DataFlash:  SIZE   4,194,304  bytes  
.................... // init_STFlash() - Initializes the pins that control the flash device. This must   
.................... //                  be called before any other flash function is used.              
.................... // 
.................... // BYTE STFlash_getByte() - Gets a byte of data from the flash device                      
.................... //                          Use after calling STFlash_startContinuousRead()               
.................... // 
.................... // void STFlash_getBytes(a, n) - Read n bytes and store in array a                               
.................... //                               Use after calling STFlash_startContinuousRead()               
.................... // 
.................... // void STFlash_readBuffer(b, i, a, n) - Read n bytes from buffer b at index i 
.................... //                                       and store in array a 
.................... // 
.................... // BYTE STFlash_readStatus() - Return the status of the flash device:   
.................... //                             Rdy/Busy Comp 0101XX 
.................... // 
.................... // void STFlash_writeToBuffer(b, i, a, n) - Write n bytes from array a to  
.................... //                                          buffer b at index i 
.................... // 
.................... // void STFlash_eraseBlock(b) - Erase all bytes in block b to 0xFF. A block is 256.     
.................... //  
.................... // The main program may define FLASH_SELECT, FLASH_CLOCK,    
.................... // FLASH_DI, and FLASH_DO to override the defaults below.   
.................... //                                       
.................... //                       Pin Layout                          
.................... //   ---------------------------------------------------     
.................... //   |    __                                           |  
.................... //   | 1: CS    FLASH_SELECT   | 8: VCC  +2.7V - +3.6V |  
.................... //   |                         |    ____               |   
.................... //   | 2: SO   FLASH_DO        | 7: HOLD  Hold         |    
.................... //   |    ___                  |                       |     
.................... //   | 3: WP    Write Protect  | 6: SCK   FLASH_CLOCK  |               
.................... //   |                         |    __                 |               
.................... //   | 4: Vss   Ground         | 5: SI     FLASH_DI    |               
.................... //   ---------------------------------------------------               
.................... //                                                                     
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //     * * * USER CONFIGURATION Section, set these per Hardware set up * * * 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define UseHWSPI   1         // Set to 1 for HW, 0 for SW, must use correct pins for HW  
....................  
.................... #define FLASH_DI     MOSI    // PIC to Flash 
.................... #define FLASH_CLOCK  SCK     // Flash Clk 
.................... #define FLASH_DO     MISO    // Flash to PIC 
.................... #define FLASH_SELECT SSEL    // Flash /CS 
....................  
.................... #define SCLKDELAY    2       // Delay in cycles, for SW driver 
.................... #define SELSDELAY    1       // Delay in us, for SW driver 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // HW SPI SSP Routines                                                              
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #if UseHWSPI 
....................     #byte SSPBUF  = 0x0FC9  
....................     #byte SSPCON  = 0x0FC6  
....................     #byte SSPSTAT = 0x0FC7  
....................     #bit  SSPBF   = SSPSTAT.0  
....................     #bit  SSPSMP  = SSPSTAT.7 
....................     #bit  SSPWCOL = SSPCON.7 
....................     #bit  SSPCKP  = SSPCON.4 
....................  
....................     #define  READ_SSP()     (SSPBUF)  
....................     #define  SSP_HAS_DATA() (SSPBF)  
....................     #define  WAIT_FOR_SSP()  while(!SSP_HAS_DATA())  
....................     #define  WRITE_SSP(chr)  SSPBUF=(chr) 
....................  
....................     int ssp_xfer(int data) { 
....................         SSPWCOL = 0;      // Precautionary Measure 
*
051C:  BCF    FC6.7
....................         WRITE_SSP(data); 
051E:  MOVFF  12F,FC9
....................         WAIT_FOR_SSP(); 
0522:  BTFSS  FC7.0
0524:  BRA    0522
....................         return(READ_SSP()); 
0526:  MOVFF  FC9,01
....................     } 
052A:  RETLW  00
....................  
....................     #define ssp_get()        ssp_xfer(0xFF) 
....................     #define ssp_put(data)    ssp_xfer(data) 
.................... #endif  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Initialize the pins that control the flash device. 
.................... //                This must be called before any other flash function is used. 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... void Init_STFlash(void) 
.................... { 
.................... #if UseHWSPI 
....................     setup_spi(spi_master | spi_h_to_l | spi_clk_div_4); 
*
0504:  BCF    FC6.5
0506:  MOVLW  30
0508:  MOVWF  FC6
050A:  MOVLW  40
050C:  MOVWF  FC7
....................     SSPCKP = 0; 
050E:  BCF    FC6.4
....................     SSPSMP = 0; 
0510:  BCF    FC7.7
.................... #else 
....................     output_low(FLASH_CLOCK); 
.................... #endif     
....................     output_high(FLASH_SELECT); 
0512:  BSF    F8B.0
.................... } 
0514:  GOTO   0568 (RETURN)
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Select the flash device 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... //------------------------------------------------------------------------------ 
.................... void STchip_select(void) 
.................... { 
.................... #if UseHWSPI 
....................    output_low(FLASH_SELECT);            // Enable select line 
0518:  BCF    F8B.0
.................... #else 
....................    output_high(FLASH_SELECT);       // Flash Select High 
....................    output_low(FLASH_CLOCK);         // Flash Clock Low 
....................    delay_ms(10); 
....................    output_low(FLASH_SELECT);            // Enable select line 
....................    delay_us(SELSDELAY);                 // Settling time 
.................... #endif 
.................... } 
051A:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Deselect the flash device 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... //------------------------------------------------------------------------------ 
.................... void STchip_deselect(void) 
.................... { 
.................... #if UseHWSPI 
....................    output_high(FLASH_SELECT);           // Disable select line 
*
0542:  BSF    F8B.0
.................... #else 
....................    output_high(FLASH_SELECT);           // Disable select line 
....................    output_low(FLASH_CLOCK);            // Pulse the clock 
....................    delay_us(SELSDELAY);                 // Settling time 
.................... #endif    
.................... } 
0544:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Send data Byte to the flash device 
.................... // Inputs:        1 byte of data 
.................... // Outputs:       None 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_SendByte(int8 data) 
.................... { 
.................... #if UseHWSPI 
....................     ssp_put(data); 
*
052C:  MOVFF  12E,12F
0530:  RCALL  051C
.................... #else 
....................     int8 i; 
....................     for(i=0; i<8; i++) { 
....................         output_bit(FLASH_DI, shift_left(&data,1,0));    // Send a data bit 
....................         output_high(FLASH_CLOCK);                       // Pulse the clock 
....................         delay_cycles(SCLKDELAY);                        // Same as a NOP 
....................         output_low(FLASH_CLOCK); 
....................         delay_cycles(SCLKDELAY);                        // Same as a NOP 
....................    } 
.................... #endif 
.................... } 
0532:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Receive data Byte from the flash device 
.................... // Inputs:        None 
.................... // Outputs:       1 byte of data 
.................... // Dependencies:  Must enter with Clock high (preceded by a send) 
.................... //------------------------------------------------------------------------------ 
.................... int8 STFlash_GetByte(void) 
.................... { 
.................... #if UseHWSPI 
....................     return(ssp_get()); 
0534:  MOVLW  FF
0536:  MOVLB  1
0538:  MOVWF  x2F
053A:  MOVLB  0
053C:  RCALL  051C
053E:  MOVF   01,W
.................... #else 
....................    int8 i, flashData; 
....................    for(i=0; i<8; i++) { 
....................        output_high(FLASH_CLOCK);                       // Pulse the clock 
....................        shift_left(&flashData, 1, input(FLASH_DO));       
....................        output_low(FLASH_CLOCK); 
....................    } 
....................    return(flashData); 
.................... #endif 
.................... } 
0540:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Get a byte of data from the flash device. This function is 
.................... //                meant to be used after STFlash_startContinuousRead() has 
.................... //                been called to initiate a continuous read. This function is 
.................... //                also used by STFlash_readPage() and STFlash_readBuffer(). 
.................... // Inputs:        1) A pointer to an array to fill 
.................... //                2) The number of bytes of data to read 
.................... // Outputs:       None 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_getBytes(int8 *data, int16 size) 
.................... { 
.................... #if UseHWSPI 
....................    int16 i; 
....................    for(i=0; i<size; ++i) { 
*
1A6E:  MOVLB  1
1A70:  CLRF   x22
1A72:  CLRF   x21
1A74:  MOVF   x22,W
1A76:  SUBWF  x20,W
1A78:  BNC   1AB4
1A7A:  BNZ   1A82
1A7C:  MOVF   x1F,W
1A7E:  SUBWF  x21,W
1A80:  BC    1AB4
....................        data[i] = ssp_get(); 
1A82:  MOVF   x1D,W
1A84:  ADDWF  x21,W
1A86:  MOVWF  01
1A88:  MOVF   x1E,W
1A8A:  ADDWFC x22,W
1A8C:  MOVWF  03
1A8E:  MOVFF  01,123
1A92:  MOVWF  x24
1A94:  MOVLW  FF
1A96:  MOVWF  x2F
1A98:  MOVLB  0
1A9A:  CALL   051C
1A9E:  MOVFF  124,FEA
1AA2:  MOVFF  123,FE9
1AA6:  MOVFF  01,FEF
....................    } 
1AAA:  MOVLB  1
1AAC:  INCF   x21,F
1AAE:  BTFSC  FD8.2
1AB0:  INCF   x22,F
1AB2:  BRA    1A74
.................... #else 
....................    int16 i; 
....................    int8  j; 
....................    for(i=0; i<size; i++) { 
....................       for(j=0; j<8; j++) { 
....................          output_high(FLASH_CLOCK); 
....................          delay_cycles(SCLKDELAY);                   // Small delay NOP 
....................          shift_left(data+i, 1, input(FLASH_DO)); 
....................          output_low(FLASH_CLOCK); 
....................          delay_cycles(SCLKDELAY);                   // Same as a NOP 
....................       } 
....................    } 
.................... #endif 
.................... } 
1AB4:  MOVLB  0
1AB6:  GOTO   1B00 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Return the Read status Register of the flash device 
.................... // Inputs:        None            ____ 
.................... // Outputs:       The Read status 
.................... // Dependencies:  STFlash_sendData(), STFlash_getByte() 
.................... //------------------------------------------------------------------------------ 
.................... int8 STFlash_readStatus() 
.................... { 
....................    int8 status; 
....................    STchip_select();                // Enable select line 
*
0546:  RCALL  0518
....................    STFlash_SendByte(0x05);         // Send status command 
0548:  MOVLW  05
054A:  MOVLB  1
054C:  MOVWF  x2E
054E:  MOVLB  0
0550:  RCALL  052C
....................    status = STFlash_GetByte();     // Get the status 
0552:  RCALL  0534
0554:  MOVFF  01,123
....................    STchip_deselect();              // Disable select line 
0558:  RCALL  0542
....................    return(status);                 // Return the status 
055A:  MOVLB  1
055C:  MOVFF  123,01
.................... } 
0560:  MOVLB  0
0562:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Wait until the flash device is ready to accept commands 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... // Dependencies:  STFlash_sendData() 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_waitUntilReady(void) 
.................... { 
....................    STchip_select();                // Enable select line 
....................    STFlash_sendByte(0x05);         // Send status command 
....................    while(input(FLASH_DO));         // Wait until ready 
....................    STFlash_GetByte();              // Get byte  
....................    STchip_deselect();              // Disable select line 
.................... } 
....................  
.................... //---------------------------------------------------------------------------- 
.................... // Purpose:       Enable Page Program write 
.................... // Inputs:        None. 
.................... // Outputs:       None. 
.................... // Dependencies:  STFlash_sendData(), STFlash_waitUntilReady() 
.................... //---------------------------------------------------------------------------- 
.................... void STFlash_WriteEnable(void) 
.................... { 
....................    STchip_select();                // Enable select line 
*
1BB6:  CALL   0518
....................    STFlash_sendByte(0x06);         // Send opcode 
1BBA:  MOVLW  06
1BBC:  MOVLB  1
1BBE:  MOVWF  x2E
1BC0:  MOVLB  0
1BC2:  CALL   052C
....................    STchip_deselect();              // Disable select line 
1BC6:  CALL   0542
.................... } 
1BCA:  RETLW  00
....................  
.................... //---------------------------------------------------------------------------- 
.................... // Purpose:       Disable Page Program write 
.................... // Inputs:        None. 
.................... // Outputs:       None. 
.................... // Dependencies:  STFlash_sendData(), STFlash_waitUntilReady() 
.................... //---------------------------------------------------------------------------- 
.................... void STFlash_WriteDisable(void) 
.................... { 
....................    STchip_select();                // Enable select line 
*
1C12:  CALL   0518
....................    STFlash_sendByte(0x04);         // Send opcode 
1C16:  MOVLW  04
1C18:  MOVLB  1
1C1A:  MOVWF  x2E
1C1C:  MOVLB  0
1C1E:  CALL   052C
....................    STchip_deselect();              // Disable select line 
1C22:  CALL   0542
.................... } 
1C26:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Write a byte to the status register of the flash device 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... // Dependencies:  STFlash_sendData(), STFlash_getByte() 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_writeStatus(int8 value) 
.................... { 
....................    STFlash_WriteEnable();          // Enable b yte writting 
*
1E98:  RCALL  1BB6
....................    STchip_select();                // Enable select line 
1E9A:  CALL   0518
....................    STFlash_sendByte(0x01);         // Send status command 
1E9E:  MOVLW  01
1EA0:  MOVLB  1
1EA2:  MOVWF  x2E
1EA4:  MOVLB  0
1EA6:  CALL   052C
....................    STFlash_sendByte(value);        // Send status value 
1EAA:  MOVFF  0F,12E
1EAE:  CALL   052C
....................    STchip_deselect();              // Disable select line 
1EB2:  CALL   0542
....................    STFlash_WriteDisable();         // Disable writting 
1EB6:  RCALL  1C12
.................... } 
1EB8:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Reads a block of data (usually 256 bytes) from the ST 
.................... //                Flash and into a buffer pointed to by int Buffer; 
.................... // 
.................... // Inputs:        1) Address of block to read from 
.................... //                2) A pointer to an array to fill 
.................... //                3) The number of bytes of data to read 
.................... // Outputs:       None 
.................... // Dependencies:  STFlash_sendData(), STFlash_getByte() 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_ReadBlock(int32 Address, int8 *buffer, int16 size) 
.................... { 
....................    STchip_select();                       // Enable select line 
*
1ABA:  CALL   0518
....................    STFlash_sendByte(0x03);                // Send opcode 
1ABE:  MOVLW  03
1AC0:  MOVLB  1
1AC2:  MOVWF  x2E
1AC4:  MOVLB  0
1AC6:  CALL   052C
....................    STFlash_sendByte(Make8(Address, 2));   // Send address  
1ACA:  MOVFF  117,11D
1ACE:  MOVFF  117,12E
1AD2:  CALL   052C
....................    STFlash_sendByte(Make8(Address, 1));   // Send address 
1AD6:  MOVFF  116,11D
1ADA:  MOVFF  116,12E
1ADE:  CALL   052C
....................    STFlash_sendByte(Make8(Address, 0));   // Send address 
1AE2:  MOVFF  115,11D
1AE6:  MOVFF  115,12E
1AEA:  CALL   052C
....................    STFlash_getBytes(buffer, size);        // Get bytes into buffer 
1AEE:  MOVFF  11A,11E
1AF2:  MOVFF  119,11D
1AF6:  MOVFF  11C,120
1AFA:  MOVFF  11B,11F
1AFE:  BRA    1A6E
....................    STchip_deselect();                     // Disable select line 
1B00:  CALL   0542
.................... } 
1B04:  GOTO   1B3C (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Send some bytes of data to the flash device 
.................... // Inputs:        1) A pointer to an array of data to send 
.................... //                2) The number of bytes to send 
.................... // Outputs:       None 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_Write1Byte(int32 Address, int8 data) 
.................... { 
....................    STFlash_WriteEnable();                 // Write 1 byte to specified address 
*
1BCC:  RCALL  1BB6
....................    STchip_select();                       // Enable select line 
1BCE:  CALL   0518
....................    STFlash_sendByte(0x02);                // Send Opcode 
1BD2:  MOVLW  02
1BD4:  MOVLB  1
1BD6:  MOVWF  x2E
1BD8:  MOVLB  0
1BDA:  CALL   052C
....................    STFlash_sendByte(Make8(Address, 2));   // Send Address  
1BDE:  MOVFF  12A,12D
1BE2:  MOVFF  12A,12E
1BE6:  CALL   052C
....................    STFlash_sendByte(Make8(Address, 1));   // Send Address 
1BEA:  MOVFF  129,12D
1BEE:  MOVFF  129,12E
1BF2:  CALL   052C
....................    STFlash_sendByte(Make8(Address, 0));   // Send Address 
1BF6:  MOVFF  128,12D
1BFA:  MOVFF  128,12E
1BFE:  CALL   052C
....................    STFlash_SendByte(data);                // Send Data 
1C02:  MOVFF  12C,12E
1C06:  CALL   052C
....................    STchip_deselect();                     // Disable select line 
1C0A:  CALL   0542
.................... } 
1C0E:  GOTO   1CA4 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Writes a block of data (usually 256 bytes) to the ST 
.................... //                Flash from a buffer pointed to by int Buffer; 
.................... // 
.................... // Inputs:        1) Address of block to read from 
.................... //                2) A pointer to an array to fill 
.................... //                3) The number of bytes of data to read 
.................... // Outputs:       None 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_WriteBlock(int32 Address, int8 *buffer, int16 size) 
.................... { 
....................     int16 i; 
....................     int32 addr; 
....................     addr = Address; 
*
1C28:  MOVFF  118,122
1C2C:  MOVFF  117,121
1C30:  MOVFF  116,120
1C34:  MOVFF  115,11F
....................     for(i = 0; i < size; i++) { 
1C38:  MOVLB  1
1C3A:  CLRF   x1E
1C3C:  CLRF   x1D
1C3E:  MOVF   x1E,W
1C40:  SUBWF  x1C,W
1C42:  BNC   1CC0
1C44:  BNZ   1C4C
1C46:  MOVF   x1B,W
1C48:  SUBWF  x1D,W
1C4A:  BC    1CC0
....................        STFlash_Write1Byte(addr++, buffer[i]); 
1C4C:  MOVFF  122,03
1C50:  MOVFF  121,02
1C54:  MOVFF  120,01
1C58:  MOVFF  11F,00
1C5C:  MOVLW  01
1C5E:  ADDWF  x1F,F
1C60:  BTFSC  FD8.0
1C62:  INCF   x20,F
1C64:  BTFSC  FD8.2
1C66:  INCF   x21,F
1C68:  BTFSC  FD8.2
1C6A:  INCF   x22,F
1C6C:  MOVFF  03,126
1C70:  MOVFF  02,125
1C74:  MOVFF  01,124
1C78:  MOVFF  00,123
1C7C:  MOVF   x19,W
1C7E:  ADDWF  x1D,W
1C80:  MOVWF  FE9
1C82:  MOVF   x1A,W
1C84:  ADDWFC x1E,W
1C86:  MOVWF  FEA
1C88:  MOVFF  FEF,127
1C8C:  MOVFF  03,12B
1C90:  MOVFF  02,12A
1C94:  MOVFF  01,129
1C98:  MOVFF  00,128
1C9C:  MOVFF  127,12C
1CA0:  MOVLB  0
1CA2:  BRA    1BCC
....................        delay_us(10); 
1CA4:  MOVLW  10
1CA6:  MOVWF  00
1CA8:  DECFSZ 00,F
1CAA:  BRA    1CA8
1CAC:  NOP   
....................        while(STFlash_readStatus() & 0x01); 
1CAE:  CALL   0546
1CB2:  BTFSC  01.0
1CB4:  BRA    1CAE
....................     } 
1CB6:  MOVLB  1
1CB8:  INCF   x1D,F
1CBA:  BTFSC  FD8.2
1CBC:  INCF   x1E,F
1CBE:  BRA    1C3E
....................     STFlash_WriteDisable(); 
1CC0:  MOVLB  0
1CC2:  RCALL  1C12
.................... } 
1CC4:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Erase a block of data (usually 256 bytes) 
.................... // 
.................... // Inputs:        1) Address of block to erase 
.................... // Outputs:       None 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_EraseBlock(int32 Address) 
.................... { 
....................    STFlash_WriteEnable();                // Enable b yte writting 
*
1DCC:  RCALL  1BB6
....................    STchip_select();                      // Enable select line 
1DCE:  CALL   0518
....................    STFlash_sendByte(0xD8);               // Send opcode 
1DD2:  MOVLW  D8
1DD4:  MOVLB  1
1DD6:  MOVWF  x2E
1DD8:  MOVLB  0
1DDA:  CALL   052C
....................    STFlash_sendByte(Make8(Address, 2));  // Send address  
1DDE:  MOVFF  15,17
1DE2:  MOVFF  15,12E
1DE6:  CALL   052C
....................    STFlash_sendByte(Make8(Address, 1));  // Send address 
1DEA:  MOVFF  14,17
1DEE:  MOVFF  14,12E
1DF2:  CALL   052C
....................    STFlash_sendByte(Make8(Address, 0));  // Send address 
1DF6:  MOVFF  13,17
1DFA:  MOVFF  13,12E
1DFE:  CALL   052C
....................    output_high(FLASH_SELECT);            // Disable select line 
1E02:  BSF    F8B.0
....................    STchip_deselect();                    // Disable select line 
1E04:  CALL   0542
....................    STFlash_WriteDisable();               // Disable writting 
1E08:  RCALL  1C12
.................... } 
1E0A:  GOTO   1E32 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Erase a block of data (usually 256 bytes) 
.................... // 
.................... // Inputs:        1) Address of block to erase 
.................... // Outputs:       None 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_Erase32KBlock(int32 Address) 
.................... { 
....................    STFlash_WriteEnable();                // Enable b yte writting 
....................    STchip_select();                      // Enable select line 
....................    STFlash_sendByte(0x52);               // Send opcode 
....................    STFlash_sendByte(Make8(Address, 2));  // Send address  
....................    STFlash_sendByte(Make8(Address, 1));  // Send address 
....................    STFlash_sendByte(Make8(Address, 0));  // Send address 
....................    output_high(FLASH_SELECT);            // Disable select line 
....................    STchip_deselect();                    // Disable select line 
....................    STFlash_WriteDisable();               // Disable writting 
.................... } 
....................  
....................  
.................... //---------------------------------------------------------------------------- 
.................... //  End .h 
.................... //---------------------------------------------------------------------------- 
....................  
....................  
.................... //-------------------------------------------------------------------------- 
.................... //    Read 256 bytes from flash and return on comm line 
.................... //-------------------------------------------------------------------------- 
.................... void Status_Flash(void) { 
....................      printf("Status=0x%02x\r\n",STFlash_readStatus()); 
*
1E54:  CALL   0546
1E58:  MOVFF  01,0F
1E5C:  CLRF   10
1E5E:  MOVF   10,W
1E60:  CALL   00AC
1E64:  INCF   10,F
1E66:  MOVWF  00
1E68:  MOVF   00,W
1E6A:  BTFSS  F9E.4
1E6C:  BRA    1E6A
1E6E:  MOVWF  FAD
1E70:  MOVLW  09
1E72:  SUBWF  10,W
1E74:  BNZ   1E5E
1E76:  MOVFF  0F,112
1E7A:  MOVLW  57
1E7C:  MOVLB  1
1E7E:  MOVWF  x13
1E80:  MOVLB  0
1E82:  RCALL  181C
1E84:  MOVLW  0D
1E86:  BTFSS  F9E.4
1E88:  BRA    1E86
1E8A:  MOVWF  FAD
1E8C:  MOVLW  0A
1E8E:  BTFSS  F9E.4
1E90:  BRA    1E8E
1E92:  MOVWF  FAD
.................... } 
1E94:  GOTO   1F9C (RETURN)
....................  
.................... //---------------------------------------------------------------------------- 
.................... //---------------------------------------------------------------------------- 
.................... //  S T    F l a s h    F u n c t i  o n s                                      
.................... //---------------------------------------------------------------------------- 
.................... //---------------------------------------------------------------------------- 
....................  
.................... //-------------------------------------------------------------------------- 
.................... // Initialize ST Flash RAM 
.................... //-------------------------------------------------------------------------- 
.................... void Init_Flash(void) 
.................... { 
....................     Init_STFlash(); // Initialize ST Flash RAM 
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
.................... // Initialize ST Flash RAM with retries,  
.................... // tries = number of times to retry befor giving up 
.................... //-------------------------------------------------------------------------- 
.................... short Try_Init_Flash(int tries) 
.................... { 
....................     short ret = 1; 
*
0564:  BSF    0E.0
....................     do { 
....................         Init_STFlash();                    // Initialize ST Card 
0566:  BRA    0504
....................         if(STFlash_readStatus() == 0x1C) { // Check Status of ST FLASH 
0568:  RCALL  0546
056A:  MOVF   01,W
056C:  SUBLW  1C
056E:  BNZ   0574
....................             ret = 0; 
0570:  BCF    0E.0
....................             break; 
0572:  BRA    057C
....................         } 
....................     } while(tries--); 
0574:  MOVF   0D,W
0576:  DECF   0D,F
0578:  XORLW  00
057A:  BNZ   0566
....................     if(verbose) { 
057C:  MOVF   0B,F
057E:  BZ    05B6
....................         if(ret) printf("Flash Init failed\r\n"); 
0580:  BTFSS  0E.0
0582:  BRA    059E
0584:  CLRF   0F
0586:  MOVF   0F,W
0588:  RCALL  00CC
058A:  INCF   0F,F
058C:  MOVWF  00
058E:  MOVF   00,W
0590:  BTFSS  F9E.4
0592:  BRA    0590
0594:  MOVWF  FAD
0596:  MOVLW  13
0598:  SUBWF  0F,W
059A:  BNZ   0586
....................         else    printf("Flash Init OK\r\n"); 
059C:  BRA    05B6
059E:  CLRF   0F
05A0:  MOVF   0F,W
05A2:  RCALL  00F0
05A4:  INCF   0F,F
05A6:  MOVWF  00
05A8:  MOVF   00,W
05AA:  BTFSS  F9E.4
05AC:  BRA    05AA
05AE:  MOVWF  FAD
05B0:  MOVLW  0F
05B2:  SUBWF  0F,W
05B4:  BNZ   05A0
....................     } 
....................     return(ret); 
05B6:  MOVLW  00
05B8:  BTFSC  0E.0
05BA:  MOVLW  01
05BC:  MOVWF  01
.................... } 
05BE:  GOTO   20C8 (RETURN)
....................  
.................... //-------------------------------------------------------------------------- 
.................... // Lock and unlock flash for writting 
.................... //-------------------------------------------------------------------------- 
.................... void unlock_flash(void) { STFlash_writeStatus(0x00); } 
*
1EBA:  CLRF   0F
1EBC:  RCALL  1E98
1EBE:  GOTO   1FA0 (RETURN)
.................... void relock_flash(void) { STFlash_writeStatus(0x1C); } 
1EC2:  MOVLW  1C
1EC4:  MOVWF  0F
1EC6:  RCALL  1E98
1EC8:  GOTO   1FA4 (RETURN)
....................  
.................... //-------------------------------------------------------------------------- 
.................... // Input hex string from std in and return 32 bit int 
.................... //-------------------------------------------------------------------------- 
.................... int32 get_address(void)  
.................... { 
....................     int32 Address;  
....................     printf("Address: 0x");   
*
1A06:  MOVLB  1
1A08:  CLRF   x19
1A0A:  MOVF   x19,W
1A0C:  MOVLB  0
1A0E:  CALL   0110
1A12:  MOVLB  1
1A14:  INCF   x19,F
1A16:  MOVWF  00
1A18:  MOVF   00,W
1A1A:  BTFSS  F9E.4
1A1C:  BRA    1A1A
1A1E:  MOVWF  FAD
1A20:  MOVLW  0B
1A22:  SUBWF  x19,W
1A24:  BNZ   1A0A
....................     Address = Make32(gethex(),gethex(),gethex(),gethex()); // Start Address 
1A26:  MOVLB  0
1A28:  RCALL  1802
1A2A:  MOVFF  01,119
1A2E:  RCALL  1802
1A30:  MOVFF  01,11A
1A34:  RCALL  1802
1A36:  MOVFF  01,11B
1A3A:  RCALL  1802
1A3C:  MOVFF  119,118
1A40:  MOVFF  11A,117
1A44:  MOVFF  11B,116
1A48:  MOVFF  01,115
....................     printf("\r\n"); 
1A4C:  MOVLW  0D
1A4E:  BTFSS  F9E.4
1A50:  BRA    1A4E
1A52:  MOVWF  FAD
1A54:  MOVLW  0A
1A56:  BTFSS  F9E.4
1A58:  BRA    1A56
1A5A:  MOVWF  FAD
....................     return(Address); 
1A5C:  MOVFF  115,00
1A60:  MOVFF  116,01
1A64:  MOVFF  117,02
1A68:  MOVFF  118,03
.................... } 
1A6C:  RETLW  00
....................  
.................... //-------------------------------------------------------------------------- 
.................... //    Read 256 bytes from flash and return on comm line 
.................... //-------------------------------------------------------------------------- 
.................... void Read_Flash(void) 
.................... { 
....................     int8  buffer[256];          // Buffer for data  
....................     int16 i; 
....................  
....................     STFlash_ReadBlock(get_address(), Buffer, 256); 
*
1B08:  RCALL  1A06
1B0A:  MOVFF  03,114
1B0E:  MOVFF  02,113
1B12:  MOVFF  01,112
1B16:  MOVFF  00,111
1B1A:  MOVFF  03,118
1B1E:  MOVFF  02,117
1B22:  MOVFF  01,116
1B26:  MOVFF  00,115
1B2A:  MOVLB  1
1B2C:  CLRF   x1A
1B2E:  MOVLW  0F
1B30:  MOVWF  x19
1B32:  MOVLW  01
1B34:  MOVWF  x1C
1B36:  CLRF   x1B
1B38:  MOVLB  0
1B3A:  BRA    1ABA
....................     for(i = 0; i < 256; i++) { 
1B3C:  MOVLB  1
1B3E:  CLRF   x10
1B40:  CLRF   x0F
1B42:  MOVF   x10,W
1B44:  SUBLW  00
1B46:  BNC   1BB0
....................         printf("0x%02x ",Buffer[i]);  // Send bytes to PC 
1B48:  MOVLW  0F
1B4A:  ADDWF  x0F,W
1B4C:  MOVWF  FE9
1B4E:  MOVLW  00
1B50:  ADDWFC x10,W
1B52:  MOVWF  FEA
1B54:  MOVFF  FEF,111
1B58:  MOVLW  30
1B5A:  BTFSS  F9E.4
1B5C:  BRA    1B5A
1B5E:  MOVWF  FAD
1B60:  MOVLW  78
1B62:  BTFSS  F9E.4
1B64:  BRA    1B62
1B66:  MOVWF  FAD
1B68:  MOVFF  111,112
1B6C:  MOVLW  57
1B6E:  MOVWF  x13
1B70:  MOVLB  0
1B72:  RCALL  181C
1B74:  MOVLW  20
1B76:  BTFSS  F9E.4
1B78:  BRA    1B76
1B7A:  MOVWF  FAD
....................         if(!((i+1)%16)) printf("\r\n"); 
1B7C:  MOVLW  01
1B7E:  MOVLB  1
1B80:  ADDWF  x0F,W
1B82:  MOVWF  x11
1B84:  MOVLW  00
1B86:  ADDWFC x10,W
1B88:  MOVWF  x12
1B8A:  MOVF   x11,W
1B8C:  ANDLW  0F
1B8E:  MOVWF  00
1B90:  CLRF   03
1B92:  MOVF   00,W
1B94:  IORWF  03,W
1B96:  BNZ   1BA8
1B98:  MOVLW  0D
1B9A:  BTFSS  F9E.4
1B9C:  BRA    1B9A
1B9E:  MOVWF  FAD
1BA0:  MOVLW  0A
1BA2:  BTFSS  F9E.4
1BA4:  BRA    1BA2
1BA6:  MOVWF  FAD
....................     } 
1BA8:  INCF   x0F,F
1BAA:  BTFSC  FD8.2
1BAC:  INCF   x10,F
1BAE:  BRA    1B42
.................... } 
1BB0:  MOVLB  0
1BB2:  GOTO   1F8C (RETURN)
....................  
.................... //-------------------------------------------------------------------------- 
.................... //    Write 256 bytes of test data to Flash 
.................... //-------------------------------------------------------------------------- 
.................... void Write_Test_Flash(void)  
.................... { 
....................     int8  Buffer[256];          // Buffer for data  
....................     int32 Address;  
....................     int16  i; 
....................      
....................     Address = get_address();                       // Start Address 
*
1D3E:  RCALL  1A06
1D40:  MOVFF  03,112
1D44:  MOVFF  02,111
1D48:  MOVFF  01,110
1D4C:  MOVFF  00,10F
....................     for(i = 0; i < 256; i++) Buffer[i] = i;      // get the 256 byte block 
1D50:  MOVLB  1
1D52:  CLRF   x14
1D54:  CLRF   x13
1D56:  MOVF   x14,W
1D58:  SUBLW  00
1D5A:  BNC   1D74
1D5C:  MOVLW  0F
1D5E:  ADDWF  x13,W
1D60:  MOVWF  FE9
1D62:  MOVLW  00
1D64:  ADDWFC x14,W
1D66:  MOVWF  FEA
1D68:  MOVFF  113,FEF
1D6C:  INCF   x13,F
1D6E:  BTFSC  FD8.2
1D70:  INCF   x14,F
1D72:  BRA    1D56
....................     STFlash_WriteBlock(Address, Buffer, 256); 
1D74:  MOVFF  112,118
1D78:  MOVFF  111,117
1D7C:  MOVFF  110,116
1D80:  MOVFF  10F,115
1D84:  CLRF   x1A
1D86:  MOVLW  0F
1D88:  MOVWF  x19
1D8A:  MOVLW  01
1D8C:  MOVWF  x1C
1D8E:  CLRF   x1B
1D90:  MOVLB  0
1D92:  RCALL  1C28
....................     if(verbose) printf("Flash test write done\r\n"); 
1D94:  MOVF   0B,F
1D96:  BZ    1DBC
1D98:  MOVLB  1
1D9A:  CLRF   x15
1D9C:  MOVF   x15,W
1D9E:  MOVLB  0
1DA0:  CALL   012C
1DA4:  MOVLB  1
1DA6:  INCF   x15,F
1DA8:  MOVWF  00
1DAA:  MOVF   00,W
1DAC:  BTFSS  F9E.4
1DAE:  BRA    1DAC
1DB0:  MOVWF  FAD
1DB2:  MOVLW  17
1DB4:  SUBWF  x15,W
1DB6:  BNZ   1D9C
....................     else        putchar('.');   // end of data indicator 
1DB8:  BRA    1DC6
1DBA:  MOVLB  0
1DBC:  MOVLW  2E
1DBE:  BTFSS  F9E.4
1DC0:  BRA    1DBE
1DC2:  MOVWF  FAD
1DC4:  MOVLB  1
.................... } 
1DC6:  MOVLB  0
1DC8:  GOTO   1F94 (RETURN)
....................  
.................... //-------------------------------------------------------------------------- 
.................... //    Write 256 bytes to Flash 
.................... //-------------------------------------------------------------------------- 
.................... void Write_Flash(void)  
.................... { 
....................     int8  Buffer[256];          // Buffer for data  
....................     int32 Address;  
....................     int16  i; 
....................      
....................     Address = Address = Make32(gethex(),gethex(),gethex(),gethex()); // Start Address 
*
1CC6:  RCALL  1802
1CC8:  MOVFF  01,115
1CCC:  RCALL  1802
1CCE:  MOVFF  01,116
1CD2:  RCALL  1802
1CD4:  MOVFF  01,117
1CD8:  RCALL  1802
1CDA:  MOVFF  115,112
1CDE:  MOVFF  116,111
1CE2:  MOVFF  117,110
1CE6:  MOVFF  01,10F
....................     for(i = 0; i < 256; i++) Buffer[i] = getch();  // get RAW 256 byte block 
1CEA:  MOVLB  1
1CEC:  CLRF   x14
1CEE:  CLRF   x13
1CF0:  MOVF   x14,W
1CF2:  SUBLW  00
1CF4:  BNC   1D12
1CF6:  MOVLW  0F
1CF8:  ADDWF  x13,W
1CFA:  MOVWF  FE9
1CFC:  MOVLW  00
1CFE:  ADDWFC x14,W
1D00:  MOVWF  FEA
1D02:  BTFSS  F9E.5
1D04:  BRA    1D02
1D06:  MOVFF  FAE,FEF
1D0A:  INCF   x13,F
1D0C:  BTFSC  FD8.2
1D0E:  INCF   x14,F
1D10:  BRA    1CF0
....................     STFlash_WriteBlock(Address, Buffer, 256); 
1D12:  MOVFF  112,118
1D16:  MOVFF  111,117
1D1A:  MOVFF  110,116
1D1E:  MOVFF  10F,115
1D22:  CLRF   x1A
1D24:  MOVLW  0F
1D26:  MOVWF  x19
1D28:  MOVLW  01
1D2A:  MOVWF  x1C
1D2C:  CLRF   x1B
1D2E:  MOVLB  0
1D30:  RCALL  1C28
....................     putchar('.');   // end of data indicator 
1D32:  MOVLW  2E
1D34:  BTFSS  F9E.4
1D36:  BRA    1D34
1D38:  MOVWF  FAD
.................... } 
1D3A:  GOTO   1F90 (RETURN)
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Erase a sector 
.................... //------------------------------------------------------------------------------ 
.................... void Erase_Sector(void)           
.................... { 
....................     STFlash_EraseBlock(get_address()); 
*
1E0E:  RCALL  1A06
1E10:  MOVFF  03,12
1E14:  MOVFF  02,11
1E18:  MOVFF  01,10
1E1C:  MOVFF  00,0F
1E20:  MOVFF  03,16
1E24:  MOVFF  02,15
1E28:  MOVFF  01,14
1E2C:  MOVFF  00,13
1E30:  BRA    1DCC
....................     if(verbose) printf("Flash erase done\r\n"); 
1E32:  MOVF   0B,F
1E34:  BZ    1E50
1E36:  CLRF   0F
1E38:  MOVF   0F,W
1E3A:  CALL   0154
1E3E:  INCF   0F,F
1E40:  MOVWF  00
1E42:  MOVF   00,W
1E44:  BTFSS  F9E.4
1E46:  BRA    1E44
1E48:  MOVWF  FAD
1E4A:  MOVLW  12
1E4C:  SUBWF  0F,W
1E4E:  BNZ   1E38
.................... } 
1E50:  GOTO   1F98 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // EEPROM Memory Map : 
.................... // PIC EEPROM is non-volital memory used store various parameters and 
.................... // prescriptions for the boot up and control of ZBC. 
.................... //------------------------------------------------------------------------------ 
.................... //   Start    End  Size Description 
.................... // ------- ------- ---- ------------------------------------------------------ 
.................... //    0x00    0x00    1 Boot type: 0 = No boot(debug) 1=RBF1 2=RBF2 
.................... //    0x01    0x03    3 Start address of RBF File 0 
.................... //    0x04    0x06    3 Size of RBF File 0 
.................... //    0x07    0x09    3 Start address of RBF File 1 
.................... //    0x0A    0x0C    3 Size of RBF File 1 
.................... //    0x0D    0x0F    3 Start address of RBF File 2 
.................... //    0x10    0x12    3 Size of RBFFile 2 
.................... // 
.................... //    0x20    0x21    1 Start of other Options 
.................... //------------------------------------------------------------------------------ 
.................... #define BOOT_LOCATION 0x00      // Boot locatoin indicator 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Flash Memory Map Example: 
.................... //------------------------------------------------------------------------------ 
.................... //     Start       End    Start      End    Flash   Actual 
.................... //   Address   Address  Address  Address    Space     Size Comment 
.................... //   ------- --------- -------- -------- -------- -------- ------------------ 
.................... //         0   131,071 0x000000 0x01FFFF  131,071  107,498 FPGA Config file #1 
.................... //   131,072   262,143 0x020000 0x03FFFF  131,071  131,071 FPGA Config file #2 
.................... //   262,144   393,213 0x040000 0x05FFFF  131,071  131,071 FPGA Config file #3 
.................... //      .         .     .        .  .        .        .    . 
.................... // 4,063,232 4,194,303 0x3E0000 0x3FFFFF  131,071  131,071 Top of Flash Space 
.................... // 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //---------------------------------------------------------------------------- 
.................... //---------------------------------------------------------------------------- 
.................... // FLASH TO FPGA Upload Function: 
.................... //---------------------------------------------------------------------------- 
.................... //---------------------------------------------------------------------------- 
.................... void FlashToFPGA(int8 rbf) 
.................... { 
....................     int8  data;                     // Location of RBF file in Flash RAM 
....................     int32 i, Length;                // Counter registers 
....................  
....................     Output_High(TestLED);            // Turn on TestLED 
*
05DE:  BSF    F8A.1
....................     Output_Low(FPGALoad);            // FPGA Upload pin 
05E0:  BCF    F89.3
....................     Delay_ms(50);                    // 50 ms delay to put FPGA into load mode 
05E2:  MOVLW  32
05E4:  MOVWF  35
05E6:  RCALL  04B6
....................     Output_High(FPGALoad);           // FPGA Upload pin 
05E8:  BSF    F89.3
....................     Delay_ms(20);                    // 50 ms delay to put FPGA into load mode 
05EA:  MOVLW  14
05EC:  MOVWF  35
05EE:  RCALL  04B6
....................     STchip_select();                        // Enable select line 
05F0:  RCALL  0518
....................     STFlash_sendByte(0x03);                 // Send opcode 
05F2:  MOVLW  03
05F4:  MOVLB  1
05F6:  MOVWF  x2E
05F8:  MOVLB  0
05FA:  RCALL  052C
....................     STFlash_sendByte(read_eeprom(rbf++));   // Send address high byte 
05FC:  MOVF   10,W
05FE:  INCF   10,F
0600:  MOVWF  1A
0602:  MOVFF  FF2,1B
0606:  BCF    FF2.7
0608:  MOVWF  FA9
060A:  BCF    FA6.6
060C:  BCF    FA6.7
060E:  BSF    FA6.0
0610:  MOVF   FA8,W
0612:  BTFSC  1B.7
0614:  BSF    FF2.7
0616:  MOVWF  1B
0618:  MOVFF  FE8,12E
061C:  RCALL  052C
....................     STFlash_sendByte(read_eeprom(rbf++));   // Send address mid byte 
061E:  MOVF   10,W
0620:  INCF   10,F
0622:  MOVWF  1A
0624:  MOVFF  FF2,1B
0628:  BCF    FF2.7
062A:  MOVWF  FA9
062C:  BCF    FA6.6
062E:  BCF    FA6.7
0630:  BSF    FA6.0
0632:  MOVF   FA8,W
0634:  BTFSC  1B.7
0636:  BSF    FF2.7
0638:  MOVWF  1B
063A:  MOVFF  FE8,12E
063E:  RCALL  052C
....................     STFlash_sendByte(read_eeprom(rbf++));   // Send address low byte 
0640:  MOVF   10,W
0642:  INCF   10,F
0644:  MOVWF  1A
0646:  MOVFF  FF2,1B
064A:  BCF    FF2.7
064C:  MOVWF  FA9
064E:  BCF    FA6.6
0650:  BCF    FA6.7
0652:  BSF    FA6.0
0654:  MOVF   FA8,W
0656:  BTFSC  1B.7
0658:  BSF    FF2.7
065A:  MOVWF  1B
065C:  MOVFF  FE8,12E
0660:  RCALL  052C
....................     Length = make32(0,read_eeprom(rbf++),read_eeprom(rbf++),read_eeprom(rbf++)); 
0662:  MOVF   10,W
0664:  INCF   10,F
0666:  MOVFF  FF2,1B
066A:  BCF    FF2.7
066C:  MOVWF  FA9
066E:  BCF    FA6.6
0670:  BCF    FA6.7
0672:  BSF    FA6.0
0674:  MOVF   FA8,W
0676:  BTFSC  1B.7
0678:  BSF    FF2.7
067A:  MOVWF  1B
067C:  MOVF   10,W
067E:  INCF   10,F
0680:  MOVFF  FF2,1D
0684:  BCF    FF2.7
0686:  MOVWF  FA9
0688:  BCF    FA6.6
068A:  BCF    FA6.7
068C:  BSF    FA6.0
068E:  MOVF   FA8,W
0690:  BTFSC  1D.7
0692:  BSF    FF2.7
0694:  MOVWF  1D
0696:  MOVF   10,W
0698:  INCF   10,F
069A:  MOVFF  FF2,1F
069E:  BCF    FF2.7
06A0:  MOVWF  FA9
06A2:  BCF    FA6.6
06A4:  BCF    FA6.7
06A6:  BSF    FA6.0
06A8:  MOVF   FA8,W
06AA:  BTFSC  1F.7
06AC:  BSF    FF2.7
06AE:  CLRF   19
06B0:  MOVFF  1B,18
06B4:  MOVFF  1D,17
06B8:  MOVWF  16
....................     for(i = 0; i < Length; i++) { 
06BA:  CLRF   15
06BC:  CLRF   14
06BE:  CLRF   13
06C0:  CLRF   12
06C2:  MOVF   15,W
06C4:  SUBWF  19,W
06C6:  BNC   06FE
06C8:  BNZ   06E0
06CA:  MOVF   14,W
06CC:  SUBWF  18,W
06CE:  BNC   06FE
06D0:  BNZ   06E0
06D2:  MOVF   13,W
06D4:  SUBWF  17,W
06D6:  BNC   06FE
06D8:  BNZ   06E0
06DA:  MOVF   16,W
06DC:  SUBWF  12,W
06DE:  BC    06FE
....................         data = STFlash_GetByte();   // get next byte from flash ram 
06E0:  RCALL  0534
06E2:  MOVFF  01,11
....................         LoadFPGAByte(data);         // Send byte to the FPGA  
06E6:  MOVFF  11,36
06EA:  RCALL  05C2
....................     } 
06EC:  MOVLW  01
06EE:  ADDWF  12,F
06F0:  BTFSC  FD8.0
06F2:  INCF   13,F
06F4:  BTFSC  FD8.2
06F6:  INCF   14,F
06F8:  BTFSC  FD8.2
06FA:  INCF   15,F
06FC:  BRA    06C2
....................     STchip_deselect();           // Disable select line 
06FE:  RCALL  0542
....................     Output_Low(TestLED);         // Turn on TestLED 
0700:  BCF    F8A.1
....................     if(verbose) printf("Flash to fpga done\r\n"); 
0702:  MOVF   0B,F
0704:  BZ    071E
0706:  CLRF   1A
0708:  MOVF   1A,W
070A:  RCALL  0178
070C:  INCF   1A,F
070E:  MOVWF  00
0710:  MOVF   00,W
0712:  BTFSS  F9E.4
0714:  BRA    0712
0716:  MOVWF  FAD
0718:  MOVLW  14
071A:  SUBWF  1A,W
071C:  BNZ   0708
.................... } 
071E:  RETLW  00
....................  
.................... //---------------------------------------------------------------------------- 
.................... // Load FPGA Firmware from flash 
.................... // erbfa = Pointer to Location of RBF file in EEPROM 
.................... //---------------------------------------------------------------------------- 
.................... void InitFPGA(int8 erbfa) 
.................... { 
....................     int8 rbf;                     // Location of RBF file in EEPROM 
....................     rbf = read_eeprom(erbfa);     // read which rbf file to read 
0720:  MOVFF  FF2,0F
0724:  BCF    FF2.7
0726:  MOVFF  0D,FA9
072A:  BCF    FA6.6
072C:  BCF    FA6.7
072E:  BSF    FA6.0
0730:  MOVF   FA8,W
0732:  BTFSC  0F.7
0734:  BSF    FF2.7
0736:  MOVWF  0E
....................     if(rbf == 0xFF) {             // if blank, then skip it 
0738:  INCFSZ 0E,W
073A:  BRA    075A
....................        if(verbose) printf("no address in eeprom\r\n"); 
073C:  MOVF   0B,F
073E:  BZ    0758
0740:  CLRF   0F
0742:  MOVF   0F,W
0744:  RCALL  019E
0746:  INCF   0F,F
0748:  MOVWF  00
074A:  MOVF   00,W
074C:  BTFSS  F9E.4
074E:  BRA    074C
0750:  MOVWF  FAD
0752:  MOVLW  16
0754:  SUBWF  0F,W
0756:  BNZ   0742
....................        return;        
0758:  BRA    0760
....................     } 
....................     FlashToFPGA(rbf);             // Load RBF 1 
075A:  MOVFF  0E,10
075E:  RCALL  05DE
.................... } 
0760:  GOTO   20DE (RETURN)
....................  
.................... //---------------------------------------------------------------------------- 
.................... // Load FPGA Firmware from flash 
.................... // Get EEPROM pointer from user console 
.................... //---------------------------------------------------------------------------- 
.................... void LoadFPGA(void) 
.................... { 
....................     if(verbose) printf("EEPROM Pointer: "); 
*
1ECC:  MOVF   0B,F
1ECE:  BZ    1EEA
1ED0:  CLRF   0F
1ED2:  MOVF   0F,W
1ED4:  CALL   01C6
1ED8:  INCF   0F,F
1EDA:  MOVWF  00
1EDC:  MOVF   00,W
1EDE:  BTFSS  F9E.4
1EE0:  BRA    1EDE
1EE2:  MOVWF  FAD
1EE4:  MOVLW  10
1EE6:  SUBWF  0F,W
1EE8:  BNZ   1ED2
....................     FlashToFPGA(gethex());                  // get pointer RBF  
1EEA:  RCALL  1802
1EEC:  MOVFF  01,0F
1EF0:  MOVFF  01,10
1EF4:  CALL   05DE
.................... } 
1EF8:  GOTO   1FA8 (RETURN)
.................... //------------------------------------------------------------------------------ 
.................... //    End .h 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //---------------------------------------------------------------------------- 
.................... //  Reset System 
.................... //---------------------------------------------------------------------------- 
.................... void ResetSystem(void) 
.................... { 
....................     Output_Low(SysReset);              // System Reset asserted 
*
04DC:  BCF    F8A.3
....................     delay_ms(250);                     // quarter second delay 
04DE:  MOVLW  FA
04E0:  MOVWF  35
04E2:  RCALL  04B6
....................     Output_High(SysReset);             // System Reset de-asserted 
04E4:  BSF    F8A.3
....................     if(verbose) printf("Reset done\r\n");  
04E6:  MOVF   0B,F
04E8:  BZ    0502
04EA:  CLRF   0F
04EC:  MOVF   0F,W
04EE:  RCALL  01E8
04F0:  INCF   0F,F
04F2:  MOVWF  00
04F4:  MOVF   00,W
04F6:  BTFSS  F9E.4
04F8:  BRA    04F6
04FA:  MOVWF  FAD
04FC:  MOVLW  0C
04FE:  SUBWF  0F,W
0500:  BNZ   04EC
.................... } 
0502:  RETLW  00
....................  
.................... //---------------------------------------------------------------------------- 
.................... // Setting Backlight PWM level:  PWM freq = 19,531Hz, PWM time => 51.2 us 
.................... // value = PWM_Duty% * PWM_time * clock/ t2div 
.................... // value = PWM_Duty% * (51.2us) 20,000,000/4 = PWM_Duty% * 256 
.................... //  
.................... // example for 50% duty cycle, 
.................... // value = .5 * 256 = 128>>2 OR /4 (shifted 2 to use 8 bit value)  
.................... // value = 32  
.................... //---------------------------------------------------------------------------- 
.................... void SetBacklight(void) 
.................... { 
....................     int8  pwm; 
....................     float brightness;  
....................     char  string[4]; 
....................          
....................     if(verbose) printf("Brightness %%: "); // prompt message 
*
120C:  MOVF   0B,F
120E:  BZ    1242
1210:  CLRF   18
1212:  MOVF   18,W
1214:  CALL   0206
1218:  INCF   18,F
121A:  MOVWF  00
121C:  MOVF   00,W
121E:  BTFSS  F9E.4
1220:  BRA    121E
1222:  MOVWF  FAD
1224:  MOVLW  0B
1226:  SUBWF  18,W
1228:  BNZ   1212
122A:  MOVLW  25
122C:  BTFSS  F9E.4
122E:  BRA    122C
1230:  MOVWF  FAD
1232:  MOVLW  3A
1234:  BTFSS  F9E.4
1236:  BRA    1234
1238:  MOVWF  FAD
123A:  MOVLW  20
123C:  BTFSS  F9E.4
123E:  BRA    123C
1240:  MOVWF  FAD
....................     string[0] = getc(); putc(string[0]); 
1242:  BTFSS  F9E.5
1244:  BRA    1242
1246:  MOVFF  FAE,14
124A:  MOVF   14,W
124C:  BTFSS  F9E.4
124E:  BRA    124C
1250:  MOVWF  FAD
....................     string[1] = getc(); putc(string[1]);  
1252:  BTFSS  F9E.5
1254:  BRA    1252
1256:  MOVFF  FAE,15
125A:  MOVF   15,W
125C:  BTFSS  F9E.4
125E:  BRA    125C
1260:  MOVWF  FAD
....................     string[2] = 0; 
1262:  CLRF   16
....................     brightness = atof(string); 
1264:  CLRF   19
1266:  MOVLW  14
1268:  MOVWF  18
126A:  BRA    0F84
126C:  MOVFF  03,13
1270:  MOVFF  02,12
1274:  MOVFF  01,11
1278:  MOVFF  00,10
....................     pwm = (brightness/100)*64; 
127C:  MOVFF  13,29
1280:  MOVFF  12,28
1284:  MOVFF  11,27
1288:  MOVFF  10,26
128C:  CLRF   2D
128E:  CLRF   2C
1290:  MOVLW  48
1292:  MOVWF  2B
1294:  MOVLW  85
1296:  MOVWF  2A
1298:  RCALL  0E2A
129A:  MOVFF  00,18
129E:  MOVFF  01,19
12A2:  MOVFF  02,1A
12A6:  MOVFF  03,1B
12AA:  MOVFF  03,28
12AE:  MOVFF  02,27
12B2:  MOVFF  01,26
12B6:  MOVFF  00,25
12BA:  CLRF   2C
12BC:  CLRF   2B
12BE:  CLRF   2A
12C0:  MOVLW  85
12C2:  MOVWF  29
12C4:  CALL   0A98
12C8:  MOVFF  03,1F
12CC:  MOVFF  02,1E
12D0:  MOVFF  01,1D
12D4:  MOVFF  00,1C
12D8:  BRA    11D2
12DA:  MOVFF  01,0F
.................... //  if(verbose) printf("pwm = 0x%02x\r\n", pwm); // debug message 
....................     Set_pwm1_duty(pwm);  
12DE:  MOVFF  0F,FBE
.................... } 
12E2:  GOTO   1F74 (RETURN)
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Detect Button press 
.................... //------------------------------------------------------------------------------ 
.................... void check_button(void)  
.................... { 
....................   if(!input(Button)) { 
*
1FBE:  BTFSC  F81.0
1FC0:  BRA    2010
....................     delay_ms (200);  //debounce 
1FC2:  MOVLW  C8
1FC4:  MOVWF  35
1FC6:  CALL   04B6
....................     if(!input(Button)) { 
1FCA:  BTFSC  F81.0
1FCC:  BRA    2010
....................       but_state = ~but_state; 
1FCE:  COMF   0C,F
....................       if(but_state) { 
1FD0:  MOVF   0C,F
1FD2:  BZ    200E
....................         if(read_eeprom(SAVED_PWM) != 0xFF) Set_pwm1_duty(read_eeprom(SAVED_PWM)); 
1FD4:  MOVFF  FF2,0D
1FD8:  BCF    FF2.7
1FDA:  MOVLW  04
1FDC:  MOVWF  FA9
1FDE:  BCF    FA6.6
1FE0:  BCF    FA6.7
1FE2:  BSF    FA6.0
1FE4:  MOVF   FA8,W
1FE6:  BTFSC  0D.7
1FE8:  BSF    FF2.7
1FEA:  SUBLW  FF
1FEC:  BZ    2008
1FEE:  MOVFF  FF2,0D
1FF2:  BCF    FF2.7
1FF4:  MOVLW  04
1FF6:  MOVWF  FA9
1FF8:  BCF    FA6.6
1FFA:  BCF    FA6.7
1FFC:  BSF    FA6.0
1FFE:  MOVF   FA8,W
2000:  BTFSC  0D.7
2002:  BSF    FF2.7
2004:  MOVWF  FBE
....................         else                               Set_pwm1_duty(0x40); // default value 
2006:  BRA    200C
2008:  MOVLW  40
200A:  MOVWF  FBE
....................       } 
....................       else                                 Set_pwm1_duty(0x00); // Backlight off 
200C:  BRA    2010
200E:  CLRF   FBE
....................     } 
....................   } 
.................... } 
2010:  GOTO   2156 (RETURN)
....................  
.................... //----------------------------------------------------------------------------- 
.................... //------------------------------------------------------------------------------ 
.................... //  Print help menu                  
.................... //----------------------------------------------------------------------------- 
.................... //------------------------------------------------------------------------------ 
.................... void helpmenu(void) 
.................... { 
....................     printf("\r\n"); 
*
0764:  MOVLW  0D
0766:  BTFSS  F9E.4
0768:  BRA    0766
076A:  MOVWF  FAD
076C:  MOVLW  0A
076E:  BTFSS  F9E.4
0770:  BRA    076E
0772:  MOVWF  FAD
....................     printf("\r\nTaboot 1.0\r\n"); 
0774:  CLRF   0F
0776:  MOVF   0F,W
0778:  RCALL  0226
077A:  INCF   0F,F
077C:  MOVWF  00
077E:  MOVF   00,W
0780:  BTFSS  F9E.4
0782:  BRA    0780
0784:  MOVWF  FAD
0786:  MOVLW  0E
0788:  SUBWF  0F,W
078A:  BNZ   0776
....................      
....................     printf("?     Show help menu\r\n"); 
078C:  MOVLW  3F
078E:  BTFSS  F9E.4
0790:  BRA    078E
0792:  MOVWF  FAD
0794:  MOVLW  05
0796:  MOVWF  0F
0798:  MOVLW  20
079A:  BTFSS  F9E.4
079C:  BRA    079A
079E:  MOVWF  FAD
07A0:  DECFSZ 0F,F
07A2:  BRA    0798
07A4:  MOVLW  01
07A6:  MOVWF  10
07A8:  MOVF   10,W
07AA:  RCALL  0246
07AC:  INCF   10,F
07AE:  MOVWF  00
07B0:  MOVF   00,W
07B2:  BTFSS  F9E.4
07B4:  BRA    07B2
07B6:  MOVWF  FAD
07B8:  MOVLW  11
07BA:  SUBWF  10,W
07BC:  BNZ   07A8
....................     printf("V/v   Set to high/low verbosity\r\n"); 
07BE:  MOVLW  56
07C0:  BTFSS  F9E.4
07C2:  BRA    07C0
07C4:  MOVWF  FAD
07C6:  MOVLW  2F
07C8:  BTFSS  F9E.4
07CA:  BRA    07C8
07CC:  MOVWF  FAD
07CE:  MOVLW  76
07D0:  BTFSS  F9E.4
07D2:  BRA    07D0
07D4:  MOVWF  FAD
07D6:  MOVLW  03
07D8:  MOVWF  0F
07DA:  MOVLW  20
07DC:  BTFSS  F9E.4
07DE:  BRA    07DC
07E0:  MOVWF  FAD
07E2:  DECFSZ 0F,F
07E4:  BRA    07DA
07E6:  MOVLW  03
07E8:  MOVWF  10
07EA:  MOVF   10,W
07EC:  RCALL  0268
07EE:  INCF   10,F
07F0:  MOVWF  00
07F2:  MOVF   00,W
07F4:  BTFSS  F9E.4
07F6:  BRA    07F4
07F8:  MOVWF  FAD
07FA:  MOVLW  1E
07FC:  SUBWF  10,W
07FE:  BNZ   07EA
....................     printf("L/l   Turn test LED ON/OFF\r\n"); 
0800:  MOVLW  4C
0802:  BTFSS  F9E.4
0804:  BRA    0802
0806:  MOVWF  FAD
0808:  MOVLW  2F
080A:  BTFSS  F9E.4
080C:  BRA    080A
080E:  MOVWF  FAD
0810:  MOVLW  6C
0812:  BTFSS  F9E.4
0814:  BRA    0812
0816:  MOVWF  FAD
0818:  MOVLW  03
081A:  MOVWF  0F
081C:  MOVLW  20
081E:  BTFSS  F9E.4
0820:  BRA    081E
0822:  MOVWF  FAD
0824:  DECFSZ 0F,F
0826:  BRA    081C
0828:  MOVLW  03
082A:  MOVWF  10
082C:  MOVF   10,W
082E:  RCALL  0298
0830:  INCF   10,F
0832:  MOVWF  00
0834:  MOVF   00,W
0836:  BTFSS  F9E.4
0838:  BRA    0836
083A:  MOVWF  FAD
083C:  MOVLW  19
083E:  SUBWF  10,W
0840:  BNZ   082C
.................... //  printf("5/0   Turn 5V PS ON/OFF\r\n"); 
....................     printf("Bnn   Set Backlight Level to nn%%\r\n"); 
0842:  MOVLW  42
0844:  BTFSS  F9E.4
0846:  BRA    0844
0848:  MOVWF  FAD
084A:  MOVLW  6E
084C:  BTFSS  F9E.4
084E:  BRA    084C
0850:  MOVWF  FAD
0852:  MOVLW  6E
0854:  BTFSS  F9E.4
0856:  BRA    0854
0858:  MOVWF  FAD
085A:  MOVLW  03
085C:  MOVWF  0F
085E:  MOVLW  20
0860:  BTFSS  F9E.4
0862:  BRA    0860
0864:  MOVWF  FAD
0866:  DECFSZ 0F,F
0868:  BRA    085E
086A:  MOVLW  03
086C:  MOVWF  10
086E:  MOVF   10,W
0870:  RCALL  02C2
0872:  INCF   10,F
0874:  MOVWF  00
0876:  MOVF   00,W
0878:  BTFSS  F9E.4
087A:  BRA    0878
087C:  MOVWF  FAD
087E:  MOVLW  1C
0880:  SUBWF  10,W
0882:  BNZ   086E
0884:  MOVLW  25
0886:  BTFSS  F9E.4
0888:  BRA    0886
088A:  MOVWF  FAD
088C:  MOVLW  0D
088E:  BTFSS  F9E.4
0890:  BRA    088E
0892:  MOVWF  FAD
0894:  MOVLW  0A
0896:  BTFSS  F9E.4
0898:  BRA    0896
089A:  MOVWF  FAD
....................     printf("U     Upload FPGA Firmware\r\n"); 
089C:  MOVLW  55
089E:  BTFSS  F9E.4
08A0:  BRA    089E
08A2:  MOVWF  FAD
08A4:  MOVLW  05
08A6:  MOVWF  0F
08A8:  MOVLW  20
08AA:  BTFSS  F9E.4
08AC:  BRA    08AA
08AE:  MOVWF  FAD
08B0:  DECFSZ 0F,F
08B2:  BRA    08A8
08B4:  MOVLW  01
08B6:  MOVWF  10
08B8:  MOVF   10,W
08BA:  RCALL  02F4
08BC:  INCF   10,F
08BE:  MOVWF  00
08C0:  MOVF   00,W
08C2:  BTFSS  F9E.4
08C4:  BRA    08C2
08C6:  MOVWF  FAD
08C8:  MOVLW  17
08CA:  SUBWF  10,W
08CC:  BNZ   08B8
....................     printf("~     System reset\r\n"); 
08CE:  MOVLW  7E
08D0:  BTFSS  F9E.4
08D2:  BRA    08D0
08D4:  MOVWF  FAD
08D6:  MOVLW  05
08D8:  MOVWF  0F
08DA:  MOVLW  20
08DC:  BTFSS  F9E.4
08DE:  BRA    08DC
08E0:  MOVWF  FAD
08E2:  DECFSZ 0F,F
08E4:  BRA    08DA
08E6:  MOVLW  01
08E8:  MOVWF  10
08EA:  MOVF   10,W
08EC:  RCALL  031C
08EE:  INCF   10,F
08F0:  MOVWF  00
08F2:  MOVF   00,W
08F4:  BTFSS  F9E.4
08F6:  BRA    08F4
08F8:  MOVWF  FAD
08FA:  MOVLW  0F
08FC:  SUBWF  10,W
08FE:  BNZ   08EA
....................     printf("raa   Read EEPROM from aa address\r\n"); 
0900:  MOVLW  72
0902:  BTFSS  F9E.4
0904:  BRA    0902
0906:  MOVWF  FAD
0908:  MOVLW  61
090A:  BTFSS  F9E.4
090C:  BRA    090A
090E:  MOVWF  FAD
0910:  MOVLW  61
0912:  BTFSS  F9E.4
0914:  BRA    0912
0916:  MOVWF  FAD
0918:  MOVLW  03
091A:  MOVWF  0F
091C:  MOVLW  20
091E:  BTFSS  F9E.4
0920:  BRA    091E
0922:  MOVWF  FAD
0924:  DECFSZ 0F,F
0926:  BRA    091C
0928:  MOVLW  03
092A:  MOVWF  10
092C:  MOVF   10,W
092E:  RCALL  033C
0930:  INCF   10,F
0932:  MOVWF  00
0934:  MOVF   00,W
0936:  BTFSS  F9E.4
0938:  BRA    0936
093A:  MOVWF  FAD
093C:  MOVLW  20
093E:  SUBWF  10,W
0940:  BNZ   092C
....................     printf("waadd Write to EEPROM address aa and data dd\r\n"); 
0942:  CLRF   0F
0944:  MOVF   0F,W
0946:  RCALL  036E
0948:  INCF   0F,F
094A:  MOVWF  00
094C:  MOVF   00,W
094E:  BTFSS  F9E.4
0950:  BRA    094E
0952:  MOVWF  FAD
0954:  MOVLW  2E
0956:  SUBWF  0F,W
0958:  BNZ   0944
....................      
.................... #if FLASHRAM 
....................     printf("R     Read 256 byte block\r\n"); 
095A:  MOVLW  52
095C:  BTFSS  F9E.4
095E:  BRA    095C
0960:  MOVWF  FAD
0962:  MOVLW  05
0964:  MOVWF  0F
0966:  MOVLW  20
0968:  BTFSS  F9E.4
096A:  BRA    0968
096C:  MOVWF  FAD
096E:  DECFSZ 0F,F
0970:  BRA    0966
0972:  MOVLW  01
0974:  MOVWF  10
0976:  MOVF   10,W
0978:  RCALL  03AE
097A:  INCF   10,F
097C:  MOVWF  00
097E:  MOVF   00,W
0980:  BTFSS  F9E.4
0982:  BRA    0980
0984:  MOVWF  FAD
0986:  MOVLW  16
0988:  SUBWF  10,W
098A:  BNZ   0976
....................     printf("W     Write 256 byte block\r\n"); 
098C:  MOVLW  57
098E:  BTFSS  F9E.4
0990:  BRA    098E
0992:  MOVWF  FAD
0994:  MOVLW  05
0996:  MOVWF  0F
0998:  MOVLW  20
099A:  BTFSS  F9E.4
099C:  BRA    099A
099E:  MOVWF  FAD
09A0:  DECFSZ 0F,F
09A2:  BRA    0998
09A4:  MOVLW  01
09A6:  MOVWF  10
09A8:  MOVF   10,W
09AA:  RCALL  03D6
09AC:  INCF   10,F
09AE:  MOVWF  00
09B0:  MOVF   00,W
09B2:  BTFSS  F9E.4
09B4:  BRA    09B2
09B6:  MOVWF  FAD
09B8:  MOVLW  17
09BA:  SUBWF  10,W
09BC:  BNZ   09A8
....................     printf("E     Erase Sector\r\n"); 
09BE:  MOVLW  45
09C0:  BTFSS  F9E.4
09C2:  BRA    09C0
09C4:  MOVWF  FAD
09C6:  MOVLW  05
09C8:  MOVWF  0F
09CA:  MOVLW  20
09CC:  BTFSS  F9E.4
09CE:  BRA    09CC
09D0:  MOVWF  FAD
09D2:  DECFSZ 0F,F
09D4:  BRA    09CA
09D6:  MOVLW  01
09D8:  MOVWF  10
09DA:  MOVF   10,W
09DC:  RCALL  03FE
09DE:  INCF   10,F
09E0:  MOVWF  00
09E2:  MOVF   00,W
09E4:  BTFSS  F9E.4
09E6:  BRA    09E4
09E8:  MOVWF  FAD
09EA:  MOVLW  0F
09EC:  SUBWF  10,W
09EE:  BNZ   09DA
....................     printf("S     Read Flash Status\r\n"); 
09F0:  MOVLW  53
09F2:  BTFSS  F9E.4
09F4:  BRA    09F2
09F6:  MOVWF  FAD
09F8:  MOVLW  05
09FA:  MOVWF  0F
09FC:  MOVLW  20
09FE:  BTFSS  F9E.4
0A00:  BRA    09FE
0A02:  MOVWF  FAD
0A04:  DECFSZ 0F,F
0A06:  BRA    09FC
0A08:  MOVLW  01
0A0A:  MOVWF  10
0A0C:  MOVF   10,W
0A0E:  RCALL  041E
0A10:  INCF   10,F
0A12:  MOVWF  00
0A14:  MOVF   00,W
0A16:  BTFSS  F9E.4
0A18:  BRA    0A16
0A1A:  MOVWF  FAD
0A1C:  MOVLW  14
0A1E:  SUBWF  10,W
0A20:  BNZ   0A0C
....................     printf("+/-   Unlock/Lock flash for writing\r\n"); 
0A22:  MOVLW  2B
0A24:  BTFSS  F9E.4
0A26:  BRA    0A24
0A28:  MOVWF  FAD
0A2A:  MOVLW  2F
0A2C:  BTFSS  F9E.4
0A2E:  BRA    0A2C
0A30:  MOVWF  FAD
0A32:  MOVLW  2D
0A34:  BTFSS  F9E.4
0A36:  BRA    0A34
0A38:  MOVWF  FAD
0A3A:  MOVLW  03
0A3C:  MOVWF  0F
0A3E:  MOVLW  20
0A40:  BTFSS  F9E.4
0A42:  BRA    0A40
0A44:  MOVWF  FAD
0A46:  DECFSZ 0F,F
0A48:  BRA    0A3E
0A4A:  MOVLW  03
0A4C:  MOVWF  10
0A4E:  MOVF   10,W
0A50:  RCALL  0444
0A52:  INCF   10,F
0A54:  MOVWF  00
0A56:  MOVF   00,W
0A58:  BTFSS  F9E.4
0A5A:  BRA    0A58
0A5C:  MOVWF  FAD
0A5E:  MOVLW  22
0A60:  SUBWF  10,W
0A62:  BNZ   0A4E
....................     printf("T     Transfer rbf File #\r\n"); 
0A64:  MOVLW  54
0A66:  BTFSS  F9E.4
0A68:  BRA    0A66
0A6A:  MOVWF  FAD
0A6C:  MOVLW  05
0A6E:  MOVWF  0F
0A70:  MOVLW  20
0A72:  BTFSS  F9E.4
0A74:  BRA    0A72
0A76:  MOVWF  FAD
0A78:  DECFSZ 0F,F
0A7A:  BRA    0A70
0A7C:  MOVLW  01
0A7E:  MOVWF  10
0A80:  MOVF   10,W
0A82:  RCALL  0478
0A84:  INCF   10,F
0A86:  MOVWF  00
0A88:  MOVF   00,W
0A8A:  BTFSS  F9E.4
0A8C:  BRA    0A8A
0A8E:  MOVWF  FAD
0A90:  MOVLW  16
0A92:  SUBWF  10,W
0A94:  BNZ   0A80
.................... #endif 
.................... } 
0A96:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... //------------------------------------------------------------------------------ 
.................... //  Process command byte                  
.................... //----------------------------------------------------------------------------- 
.................... //------------------------------------------------------------------------------ 
.................... void proc_cmd(int8 cmd) 
.................... { 
....................     switch(cmd) {                                    // Switch on the command 
*
1EFC:  MOVF   0E,W
1EFE:  XORLW  3F
1F00:  BZ    1F50
1F02:  XORLW  69
1F04:  BZ    1F56
1F06:  XORLW  20
1F08:  BZ    1F5C
1F0A:  XORLW  3A
1F0C:  BZ    1F60
1F0E:  XORLW  20
1F10:  BZ    1F64
1F12:  XORLW  59
1F14:  BZ    1F68
1F16:  XORLW  05
1F18:  BZ    1F6C
1F1A:  XORLW  72
1F1C:  BZ    1F70
1F1E:  XORLW  3C
1F20:  BZ    1F76
1F22:  XORLW  2B
1F24:  BZ    1F7C
1F26:  XORLW  27
1F28:  BZ    1F82
1F2A:  XORLW  05
1F2C:  BZ    1F86
1F2E:  XORLW  25
1F30:  BZ    1F8A
1F32:  XORLW  05
1F34:  BZ    1F8E
1F36:  XORLW  36
1F38:  BZ    1F92
1F3A:  XORLW  24
1F3C:  BZ    1F96
1F3E:  XORLW  16
1F40:  BZ    1F9A
1F42:  XORLW  78
1F44:  BZ    1F9E
1F46:  XORLW  06
1F48:  BZ    1FA2
1F4A:  XORLW  79
1F4C:  BZ    1FA6
1F4E:  BRA    1FAA
....................         case '?': {helpmenu();              } break; // print help menu 
1F50:  CALL   0764
1F54:  BRA    1FAE
....................         case 'V': {verbose = TRUE;          } break; // Set to high verbosity 
1F56:  MOVLW  01
1F58:  MOVWF  0B
1F5A:  BRA    1FAE
....................         case 'v': {verbose = FALSE;         } break; // Set to low verbosity 
1F5C:  CLRF   0B
1F5E:  BRA    1FAE
....................         case 'L': {set(TestLED);            } break; // Turn Test LED On 
1F60:  BSF    F8A.1
1F62:  BRA    1FAE
....................         case 'l': {clr(TestLED);            } break; // Turn Test LED Off 
1F64:  BCF    F8A.1
1F66:  BRA    1FAE
....................         case '5': {set(PS5V_EN);            } break; // Turn 5V PS On 
1F68:  BSF    F89.5
1F6A:  BRA    1FAE
....................         case '0': {clr(PS5V_EN);            } break; // Turn 5V PS Off 
1F6C:  BCF    F89.5
1F6E:  BRA    1FAE
....................         case 'B': {SetBacklight();          } break; // Backlight off 
1F70:  GOTO   120C
1F74:  BRA    1FAE
....................         case '~': {ResetSystem();           } break; // Reset FPGA 
1F76:  CALL   04DC
1F7A:  BRA    1FAE
....................         case 'U': {Upload_RBF();            } break; // Upload FPGA RBF file 
1F7C:  GOTO   16DC
1F80:  BRA    1FAE
....................         case 'r': {ee_read();               } break; // Read EEPROM 
1F82:  BRA    1862
1F84:  BRA    1FAE
....................         case 'w': {ee_write();              } break; // Write to EEPROM 
1F86:  BRA    1920
1F88:  BRA    1FAE
....................  
....................     #if FLASHRAM 
....................         case 'R': {Read_Flash();            } break; // Read 256 byte block 
1F8A:  BRA    1B08
1F8C:  BRA    1FAE
....................         case 'W': {Write_Flash();           } break; // Write 256 byte block 
1F8E:  BRA    1CC6
1F90:  BRA    1FAE
....................         case 'a': {Write_Test_Flash();      } break; // Write 256 byte Test block 
1F92:  BRA    1D3E
1F94:  BRA    1FAE
....................         case 'E': {Erase_Sector();          } break; // Erase Sector 
1F96:  BRA    1E0E
1F98:  BRA    1FAE
....................         case 'S': {Status_Flash();          } break; // Read Flash Status 
1F9A:  BRA    1E54
1F9C:  BRA    1FAE
....................         case '+': {unlock_flash();          } break; // Unlock Flash for writting 
1F9E:  BRA    1EBA
1FA0:  BRA    1FAE
....................         case '-': {relock_flash();          } break; // relock Flash for writting 
1FA2:  BRA    1EC2
1FA4:  BRA    1FAE
....................         case 'T': {LoadFPGA();              } break; // Transfer rbf # 
1FA6:  BRA    1ECC
1FA8:  BRA    1FAE
....................     #endif 
....................          default: cmd = 0x00;                 break; // invalid command 
1FAA:  CLRF   0E
1FAC:  BRA    1FAE
....................     }                                                // End of case loop 
....................     if(cmd) putchar(cmd);   // Echo command byte back 
1FAE:  MOVF   0E,F
1FB0:  BZ    1FBA
1FB2:  MOVF   0E,W
1FB4:  BTFSS  F9E.4
1FB6:  BRA    1FB4
1FB8:  MOVWF  FAD
.................... } 
1FBA:  GOTO   2138 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  End .h 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // Main Program 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... void main(void) 
.................... { 
*
2014:  CLRF   FF8
2016:  BCF    FD0.7
2018:  CLRF   FEA
201A:  CLRF   FE9
201C:  BSF    FB8.3
201E:  MOVLW  15
2020:  MOVWF  FAF
2022:  MOVLW  00
2024:  MOVWF  FB0
2026:  MOVLW  A6
2028:  MOVWF  FAC
202A:  MOVLW  90
202C:  MOVWF  FAB
202E:  MOVF   FC1,W
2030:  ANDLW  C0
2032:  IORLW  0F
2034:  MOVWF  FC1
2036:  MOVLW  07
2038:  MOVWF  FB4
203A:  CLRF   05
203C:  CLRF   06
....................     setup_adc_ports(NO_ANALOGS|VSS_VDD);        // No ADC needed 
203E:  MOVF   FC1,W
2040:  ANDLW  C0
2042:  IORLW  0F
2044:  MOVWF  FC1
....................     setup_adc(ADC_OFF|ADC_TAD_MUL_0);           // No ADC needed 
2046:  BCF    FC2.0
....................     setup_vref(FALSE);                          // V ref not needed 
2048:  CLRF   FB5
....................     setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256);  // Nominal timing 
204A:  MOVLW  87
204C:  MOVWF  FD5
....................     setup_timer_1(T1_DISABLED);                 // Not needed 
204E:  CLRF   FCD
....................     setup_timer_2(T2_DIV_BY_4,64,1);            // 20Mhz/4/4/64 = 19,531Hz 
2050:  MOVLW  00
2052:  IORLW  05
2054:  MOVWF  FCA
2056:  MOVLW  40
2058:  MOVWF  FCB
....................  
....................     Set_Tris_A(0b11110001);           // Port A, All Digital 
205A:  MOVLW  F1
205C:  MOVWF  F92
....................     Set_Tris_B(0b11110101);           // Port B,  All Digital 
205E:  MOVLW  F5
2060:  MOVWF  F93
....................     Set_Tris_C(0b10010010);           // Set up for RS232 & SPI 
2062:  MOVLW  92
2064:  MOVWF  F94
....................     Port_B_Pullups(True);             // Turn on port B pull ups 
2066:  BCF    FF1.7
....................  
....................     Clr(TESTLED);                     // Turn off status LED 
2068:  BCF    F8A.1
....................     Clr(BACKLITE);                    // Turn off status LCD 
206A:  BCF    F8B.2
....................     Set(FPGALoad);                    // FPGA Upload pin, not loading 
206C:  BSF    F89.3
....................  
....................     but_state = 0;                    // initial button state is off 
206E:  CLRF   0C
....................  
....................     Setup_ccp1(CCP_PWM);              // Configure CCP1 as a PWM 
2070:  MOVLW  B7
2072:  ANDWF  FB1,F
2074:  BCF    F8B.2
2076:  MOVLW  0C
2078:  MOVWF  FBD
....................     Set_pwm1_duty(0x00);              // Backlight off 
207A:  CLRF   FBE
....................  
....................     delay_ms(100);                    // small delay 
207C:  MOVLW  64
207E:  MOVWF  35
2080:  CALL   04B6
....................  
....................     verbose = read_eeprom(INIT_VERB); // Get verbosity level 
2084:  MOVFF  FF2,0D
2088:  BCF    FF2.7
208A:  MOVLW  02
208C:  MOVWF  FA9
208E:  BCF    FA6.6
2090:  BCF    FA6.7
2092:  BSF    FA6.0
2094:  MOVF   FA8,W
2096:  BTFSC  0D.7
2098:  BSF    FF2.7
209A:  MOVWF  0B
....................      
....................     if(read_eeprom(INIT_RESET) == 0x01) ResetSystem(); // System Reset flag 
209C:  MOVFF  FF2,0D
20A0:  BCF    FF2.7
20A2:  MOVLW  01
20A4:  MOVWF  FA9
20A6:  BCF    FA6.6
20A8:  BCF    FA6.7
20AA:  BSF    FA6.0
20AC:  MOVF   FA8,W
20AE:  BTFSC  0D.7
20B0:  BSF    FF2.7
20B2:  SUBLW  01
20B4:  BNZ   20BC
20B6:  CALL   04DC
....................     else                                Output_High(SysReset); 
20BA:  BRA    20BE
20BC:  BSF    F8A.3
....................  
....................     Set(TESTLED);                   // Turn On status LED 
20BE:  BSF    F8A.1
....................     #if FLASHRAM                    // If Flash RAM support code on 
....................         Try_Init_Flash(5);          // Try to init 5 times 
20C0:  MOVLW  05
20C2:  MOVWF  0D
20C4:  GOTO   0564
....................         delay_ms(400);              // small delay 
20C8:  MOVLW  02
20CA:  MOVWF  0D
20CC:  MOVLW  C8
20CE:  MOVWF  35
20D0:  CALL   04B6
20D4:  DECFSZ 0D,F
20D6:  BRA    20CC
....................         InitFPGA(INIT_RBF);         // Initial load of FPGA 
20D8:  CLRF   0D
20DA:  GOTO   0720
....................     #endif                          // End if 
....................  
....................     if(read_eeprom(INIT_PWM) != 0xFF) Set_pwm1_duty(read_eeprom(INIT_PWM)); 
20DE:  MOVFF  FF2,0D
20E2:  BCF    FF2.7
20E4:  MOVLW  03
20E6:  MOVWF  FA9
20E8:  BCF    FA6.6
20EA:  BCF    FA6.7
20EC:  BSF    FA6.0
20EE:  MOVF   FA8,W
20F0:  BTFSC  0D.7
20F2:  BSF    FF2.7
20F4:  SUBLW  FF
20F6:  BZ    2112
20F8:  MOVFF  FF2,0D
20FC:  BCF    FF2.7
20FE:  MOVLW  03
2100:  MOVWF  FA9
2102:  BCF    FA6.6
2104:  BCF    FA6.7
2106:  BSF    FA6.0
2108:  MOVF   FA8,W
210A:  BTFSC  0D.7
210C:  BSF    FF2.7
210E:  MOVWF  FBE
....................     else                              Set_pwm1_duty(0x00);  // Backlight off 
2110:  BRA    2114
2112:  CLRF   FBE
....................  
....................     Clr(TESTLED);                   // Turn off status LED 
2114:  BCF    F8A.1
....................  
....................     if(verbose) helpmenu();         // print help menu 
2116:  MOVF   0B,F
2118:  BZ    211E
211A:  CALL   0764
....................     printf(">");                    // Print prompt 
211E:  MOVLW  3E
2120:  BTFSS  F9E.4
2122:  BRA    2120
2124:  MOVWF  FAD
....................     do { 
....................         if(kbhit()) { 
2126:  BTFSS  F9E.5
2128:  BRA    2154
....................             proc_cmd(getch());      // Process command byte 
212A:  BTFSS  F9E.5
212C:  BRA    212A
212E:  MOVFF  FAE,0D
2132:  MOVFF  FAE,0E
2136:  BRA    1EFC
....................             printf("\r\n> ");       // Print carriage return and line feed 
2138:  CLRF   0D
213A:  MOVF   0D,W
213C:  CALL   04A0
2140:  INCF   0D,F
2142:  MOVWF  00
2144:  MOVF   00,W
2146:  BTFSS  F9E.4
2148:  BRA    2146
214A:  MOVWF  FAD
214C:  MOVLW  04
214E:  SUBWF  0D,W
2150:  BNZ   213A
....................         } 
....................         else { 
2152:  BRA    2156
....................             check_button();         // check button press 
2154:  BRA    1FBE
....................         } 
....................     } while(TRUE); 
.................... } 
2156:  BRA    2126
.................... //------------------------------------------------------------------------------ 
.................... // End.c 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
2158:  SLEEP 

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN RESERVED
   Word  2: 1E19   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768
   Word  3: 8300   PBADEN CCP2C1 NOLPT1OSC MCLR RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
